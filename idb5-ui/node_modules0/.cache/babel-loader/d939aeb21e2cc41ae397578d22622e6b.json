{"ast":null,"code":"/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\nvar bufferUtil = require('bufferutil');\n\nvar bufferAllocUnsafe = require('./utils').bufferAllocUnsafe;\n\nconst DECODE_HEADER = 1;\nconst WAITING_FOR_16_BIT_LENGTH = 2;\nconst WAITING_FOR_64_BIT_LENGTH = 3;\nconst WAITING_FOR_MASK_KEY = 4;\nconst WAITING_FOR_PAYLOAD = 5;\nconst COMPLETE = 6; // WebSocketConnection will pass shared buffer objects for maskBytes and\n// frameHeader into the constructor to avoid tons of small memory allocations\n// for each frame we have to parse.  This is only used for parsing frames\n// we receive off the wire.\n\nfunction WebSocketFrame(maskBytes, frameHeader, config) {\n  this.maskBytes = maskBytes;\n  this.frameHeader = frameHeader;\n  this.config = config;\n  this.maxReceivedFrameSize = config.maxReceivedFrameSize;\n  this.protocolError = false;\n  this.frameTooLarge = false;\n  this.invalidCloseFrameLength = false;\n  this.parseState = DECODE_HEADER;\n  this.closeStatus = -1;\n}\n\nWebSocketFrame.prototype.addData = function (bufferList) {\n  if (this.parseState === DECODE_HEADER) {\n    if (bufferList.length >= 2) {\n      bufferList.joinInto(this.frameHeader, 0, 0, 2);\n      bufferList.advance(2);\n      var firstByte = this.frameHeader[0];\n      var secondByte = this.frameHeader[1];\n      this.fin = Boolean(firstByte & 0x80);\n      this.rsv1 = Boolean(firstByte & 0x40);\n      this.rsv2 = Boolean(firstByte & 0x20);\n      this.rsv3 = Boolean(firstByte & 0x10);\n      this.mask = Boolean(secondByte & 0x80);\n      this.opcode = firstByte & 0x0F;\n      this.length = secondByte & 0x7F; // Control frame sanity check\n\n      if (this.opcode >= 0x08) {\n        if (this.length > 125) {\n          this.protocolError = true;\n          this.dropReason = 'Illegal control frame longer than 125 bytes.';\n          return true;\n        }\n\n        if (!this.fin) {\n          this.protocolError = true;\n          this.dropReason = 'Control frames must not be fragmented.';\n          return true;\n        }\n      }\n\n      if (this.length === 126) {\n        this.parseState = WAITING_FOR_16_BIT_LENGTH;\n      } else if (this.length === 127) {\n        this.parseState = WAITING_FOR_64_BIT_LENGTH;\n      } else {\n        this.parseState = WAITING_FOR_MASK_KEY;\n      }\n    }\n  }\n\n  if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {\n    if (bufferList.length >= 2) {\n      bufferList.joinInto(this.frameHeader, 2, 0, 2);\n      bufferList.advance(2);\n      this.length = this.frameHeader.readUInt16BE(2);\n      this.parseState = WAITING_FOR_MASK_KEY;\n    }\n  } else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {\n    if (bufferList.length >= 8) {\n      bufferList.joinInto(this.frameHeader, 2, 0, 8);\n      bufferList.advance(8);\n      var lengthPair = [this.frameHeader.readUInt32BE(2), this.frameHeader.readUInt32BE(2 + 4)];\n\n      if (lengthPair[0] !== 0) {\n        this.protocolError = true;\n        this.dropReason = 'Unsupported 64-bit length frame received';\n        return true;\n      }\n\n      this.length = lengthPair[1];\n      this.parseState = WAITING_FOR_MASK_KEY;\n    }\n  }\n\n  if (this.parseState === WAITING_FOR_MASK_KEY) {\n    if (this.mask) {\n      if (bufferList.length >= 4) {\n        bufferList.joinInto(this.maskBytes, 0, 0, 4);\n        bufferList.advance(4);\n        this.parseState = WAITING_FOR_PAYLOAD;\n      }\n    } else {\n      this.parseState = WAITING_FOR_PAYLOAD;\n    }\n  }\n\n  if (this.parseState === WAITING_FOR_PAYLOAD) {\n    if (this.length > this.maxReceivedFrameSize) {\n      this.frameTooLarge = true;\n      this.dropReason = 'Frame size of ' + this.length.toString(10) + ' bytes exceeds maximum accepted frame size';\n      return true;\n    }\n\n    if (this.length === 0) {\n      this.binaryPayload = bufferAllocUnsafe(0);\n      this.parseState = COMPLETE;\n      return true;\n    }\n\n    if (bufferList.length >= this.length) {\n      this.binaryPayload = bufferList.take(this.length);\n      bufferList.advance(this.length);\n\n      if (this.mask) {\n        bufferUtil.unmask(this.binaryPayload, this.maskBytes); // xor(this.binaryPayload, this.maskBytes, 0);\n      }\n\n      if (this.opcode === 0x08) {\n        // WebSocketOpcode.CONNECTION_CLOSE\n        if (this.length === 1) {\n          // Invalid length for a close frame.  Must be zero or at least two.\n          this.binaryPayload = bufferAllocUnsafe(0);\n          this.invalidCloseFrameLength = true;\n        }\n\n        if (this.length >= 2) {\n          this.closeStatus = this.binaryPayload.readUInt16BE(0);\n          this.binaryPayload = this.binaryPayload.slice(2);\n        }\n      }\n\n      this.parseState = COMPLETE;\n      return true;\n    }\n  }\n\n  return false;\n};\n\nWebSocketFrame.prototype.throwAwayPayload = function (bufferList) {\n  if (bufferList.length >= this.length) {\n    bufferList.advance(this.length);\n    this.parseState = COMPLETE;\n    return true;\n  }\n\n  return false;\n};\n\nWebSocketFrame.prototype.toBuffer = function (nullMask) {\n  var maskKey;\n  var headerLength = 2;\n  var data;\n  var outputPos;\n  var firstByte = 0x00;\n  var secondByte = 0x00;\n\n  if (this.fin) {\n    firstByte |= 0x80;\n  }\n\n  if (this.rsv1) {\n    firstByte |= 0x40;\n  }\n\n  if (this.rsv2) {\n    firstByte |= 0x20;\n  }\n\n  if (this.rsv3) {\n    firstByte |= 0x10;\n  }\n\n  if (this.mask) {\n    secondByte |= 0x80;\n  }\n\n  firstByte |= this.opcode & 0x0F; // the close frame is a special case because the close reason is\n  // prepended to the payload data.\n\n  if (this.opcode === 0x08) {\n    this.length = 2;\n\n    if (this.binaryPayload) {\n      this.length += this.binaryPayload.length;\n    }\n\n    data = bufferAllocUnsafe(this.length);\n    data.writeUInt16BE(this.closeStatus, 0);\n\n    if (this.length > 2) {\n      this.binaryPayload.copy(data, 2);\n    }\n  } else if (this.binaryPayload) {\n    data = this.binaryPayload;\n    this.length = data.length;\n  } else {\n    this.length = 0;\n  }\n\n  if (this.length <= 125) {\n    // encode the length directly into the two-byte frame header\n    secondByte |= this.length & 0x7F;\n  } else if (this.length > 125 && this.length <= 0xFFFF) {\n    // Use 16-bit length\n    secondByte |= 126;\n    headerLength += 2;\n  } else if (this.length > 0xFFFF) {\n    // Use 64-bit length\n    secondByte |= 127;\n    headerLength += 8;\n  }\n\n  var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0)); // write the frame header\n\n  output[0] = firstByte;\n  output[1] = secondByte;\n  outputPos = 2;\n\n  if (this.length > 125 && this.length <= 0xFFFF) {\n    // write 16-bit length\n    output.writeUInt16BE(this.length, outputPos);\n    outputPos += 2;\n  } else if (this.length > 0xFFFF) {\n    // write 64-bit length\n    output.writeUInt32BE(0x00000000, outputPos);\n    output.writeUInt32BE(this.length, outputPos + 4);\n    outputPos += 8;\n  }\n\n  if (this.mask) {\n    maskKey = nullMask ? 0 : Math.random() * 0xFFFFFFFF >>> 0;\n    this.maskBytes.writeUInt32BE(maskKey, 0); // write the mask key\n\n    this.maskBytes.copy(output, outputPos);\n    outputPos += 4;\n\n    if (data) {\n      bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);\n    }\n  } else if (data) {\n    data.copy(output, outputPos);\n  }\n\n  return output;\n};\n\nWebSocketFrame.prototype.toString = function () {\n  return 'Opcode: ' + this.opcode + ', fin: ' + this.fin + ', length: ' + this.length + ', hasPayload: ' + Boolean(this.binaryPayload) + ', masked: ' + this.mask;\n};\n\nmodule.exports = WebSocketFrame;","map":{"version":3,"sources":["/home/thaumy/Desktop/idb5-ui/node_modules/websocket/lib/WebSocketFrame.js"],"names":["bufferUtil","require","bufferAllocUnsafe","DECODE_HEADER","WAITING_FOR_16_BIT_LENGTH","WAITING_FOR_64_BIT_LENGTH","WAITING_FOR_MASK_KEY","WAITING_FOR_PAYLOAD","COMPLETE","WebSocketFrame","maskBytes","frameHeader","config","maxReceivedFrameSize","protocolError","frameTooLarge","invalidCloseFrameLength","parseState","closeStatus","prototype","addData","bufferList","length","joinInto","advance","firstByte","secondByte","fin","Boolean","rsv1","rsv2","rsv3","mask","opcode","dropReason","readUInt16BE","lengthPair","readUInt32BE","toString","binaryPayload","take","unmask","slice","throwAwayPayload","toBuffer","nullMask","maskKey","headerLength","data","outputPos","writeUInt16BE","copy","output","writeUInt32BE","Math","random","module","exports"],"mappings":"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","sourcesContent":["/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar bufferUtil = require('bufferutil');\nvar bufferAllocUnsafe = require('./utils').bufferAllocUnsafe;\n\nconst DECODE_HEADER = 1;\nconst WAITING_FOR_16_BIT_LENGTH = 2;\nconst WAITING_FOR_64_BIT_LENGTH = 3;\nconst WAITING_FOR_MASK_KEY = 4;\nconst WAITING_FOR_PAYLOAD = 5;\nconst COMPLETE = 6;\n\n// WebSocketConnection will pass shared buffer objects for maskBytes and\n// frameHeader into the constructor to avoid tons of small memory allocations\n// for each frame we have to parse.  This is only used for parsing frames\n// we receive off the wire.\nfunction WebSocketFrame(maskBytes, frameHeader, config) {\n    this.maskBytes = maskBytes;\n    this.frameHeader = frameHeader;\n    this.config = config;\n    this.maxReceivedFrameSize = config.maxReceivedFrameSize;\n    this.protocolError = false;\n    this.frameTooLarge = false;\n    this.invalidCloseFrameLength = false;\n    this.parseState = DECODE_HEADER;\n    this.closeStatus = -1;\n}\n\nWebSocketFrame.prototype.addData = function(bufferList) {\n    if (this.parseState === DECODE_HEADER) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 0, 0, 2);\n            bufferList.advance(2);\n            var firstByte = this.frameHeader[0];\n            var secondByte = this.frameHeader[1];\n\n            this.fin     = Boolean(firstByte  & 0x80);\n            this.rsv1    = Boolean(firstByte  & 0x40);\n            this.rsv2    = Boolean(firstByte  & 0x20);\n            this.rsv3    = Boolean(firstByte  & 0x10);\n            this.mask    = Boolean(secondByte & 0x80);\n\n            this.opcode  = firstByte  & 0x0F;\n            this.length = secondByte & 0x7F;\n\n            // Control frame sanity check\n            if (this.opcode >= 0x08) {\n                if (this.length > 125) {\n                    this.protocolError = true;\n                    this.dropReason = 'Illegal control frame longer than 125 bytes.';\n                    return true;\n                }\n                if (!this.fin) {\n                    this.protocolError = true;\n                    this.dropReason = 'Control frames must not be fragmented.';\n                    return true;\n                }\n            }\n\n            if (this.length === 126) {\n                this.parseState = WAITING_FOR_16_BIT_LENGTH;\n            }\n            else if (this.length === 127) {\n                this.parseState = WAITING_FOR_64_BIT_LENGTH;\n            }\n            else {\n                this.parseState = WAITING_FOR_MASK_KEY;\n            }\n        }\n    }\n    if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 2);\n            bufferList.advance(2);\n            this.length = this.frameHeader.readUInt16BE(2);\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    }\n    else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {\n        if (bufferList.length >= 8) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 8);\n            bufferList.advance(8);\n            var lengthPair = [\n              this.frameHeader.readUInt32BE(2),\n              this.frameHeader.readUInt32BE(2+4)\n            ];\n\n            if (lengthPair[0] !== 0) {\n                this.protocolError = true;\n                this.dropReason = 'Unsupported 64-bit length frame received';\n                return true;\n            }\n            this.length = lengthPair[1];\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    }\n\n    if (this.parseState === WAITING_FOR_MASK_KEY) {\n        if (this.mask) {\n            if (bufferList.length >= 4) {\n                bufferList.joinInto(this.maskBytes, 0, 0, 4);\n                bufferList.advance(4);\n                this.parseState = WAITING_FOR_PAYLOAD;\n            }\n        }\n        else {\n            this.parseState = WAITING_FOR_PAYLOAD;\n        }\n    }\n\n    if (this.parseState === WAITING_FOR_PAYLOAD) {\n        if (this.length > this.maxReceivedFrameSize) {\n            this.frameTooLarge = true;\n            this.dropReason = 'Frame size of ' + this.length.toString(10) +\n                              ' bytes exceeds maximum accepted frame size';\n            return true;\n        }\n\n        if (this.length === 0) {\n            this.binaryPayload = bufferAllocUnsafe(0);\n            this.parseState = COMPLETE;\n            return true;\n        }\n        if (bufferList.length >= this.length) {\n            this.binaryPayload = bufferList.take(this.length);\n            bufferList.advance(this.length);\n            if (this.mask) {\n                bufferUtil.unmask(this.binaryPayload, this.maskBytes);\n                // xor(this.binaryPayload, this.maskBytes, 0);\n            }\n\n            if (this.opcode === 0x08) { // WebSocketOpcode.CONNECTION_CLOSE\n                if (this.length === 1) {\n                    // Invalid length for a close frame.  Must be zero or at least two.\n                    this.binaryPayload = bufferAllocUnsafe(0);\n                    this.invalidCloseFrameLength = true;\n                }\n                if (this.length >= 2) {\n                    this.closeStatus = this.binaryPayload.readUInt16BE(0);\n                    this.binaryPayload = this.binaryPayload.slice(2);\n                }\n            }\n\n            this.parseState = COMPLETE;\n            return true;\n        }\n    }\n    return false;\n};\n\nWebSocketFrame.prototype.throwAwayPayload = function(bufferList) {\n    if (bufferList.length >= this.length) {\n        bufferList.advance(this.length);\n        this.parseState = COMPLETE;\n        return true;\n    }\n    return false;\n};\n\nWebSocketFrame.prototype.toBuffer = function(nullMask) {\n    var maskKey;\n    var headerLength = 2;\n    var data;\n    var outputPos;\n    var firstByte = 0x00;\n    var secondByte = 0x00;\n\n    if (this.fin) {\n        firstByte |= 0x80;\n    }\n    if (this.rsv1) {\n        firstByte |= 0x40;\n    }\n    if (this.rsv2) {\n        firstByte |= 0x20;\n    }\n    if (this.rsv3) {\n        firstByte |= 0x10;\n    }\n    if (this.mask) {\n        secondByte |= 0x80;\n    }\n\n    firstByte |= (this.opcode & 0x0F);\n\n    // the close frame is a special case because the close reason is\n    // prepended to the payload data.\n    if (this.opcode === 0x08) {\n        this.length = 2;\n        if (this.binaryPayload) {\n            this.length += this.binaryPayload.length;\n        }\n        data = bufferAllocUnsafe(this.length);\n        data.writeUInt16BE(this.closeStatus, 0);\n        if (this.length > 2) {\n            this.binaryPayload.copy(data, 2);\n        }\n    }\n    else if (this.binaryPayload) {\n        data = this.binaryPayload;\n        this.length = data.length;\n    }\n    else {\n        this.length = 0;\n    }\n\n    if (this.length <= 125) {\n        // encode the length directly into the two-byte frame header\n        secondByte |= (this.length & 0x7F);\n    }\n    else if (this.length > 125 && this.length <= 0xFFFF) {\n        // Use 16-bit length\n        secondByte |= 126;\n        headerLength += 2;\n    }\n    else if (this.length > 0xFFFF) {\n        // Use 64-bit length\n        secondByte |= 127;\n        headerLength += 8;\n    }\n\n    var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));\n\n    // write the frame header\n    output[0] = firstByte;\n    output[1] = secondByte;\n\n    outputPos = 2;\n\n    if (this.length > 125 && this.length <= 0xFFFF) {\n        // write 16-bit length\n        output.writeUInt16BE(this.length, outputPos);\n        outputPos += 2;\n    }\n    else if (this.length > 0xFFFF) {\n        // write 64-bit length\n        output.writeUInt32BE(0x00000000, outputPos);\n        output.writeUInt32BE(this.length, outputPos + 4);\n        outputPos += 8;\n    }\n\n    if (this.mask) {\n        maskKey = nullMask ? 0 : ((Math.random() * 0xFFFFFFFF) >>> 0);\n        this.maskBytes.writeUInt32BE(maskKey, 0);\n\n        // write the mask key\n        this.maskBytes.copy(output, outputPos);\n        outputPos += 4;\n\n        if (data) {\n          bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);\n        }\n    }\n    else if (data) {\n        data.copy(output, outputPos);\n    }\n\n    return output;\n};\n\nWebSocketFrame.prototype.toString = function() {\n    return 'Opcode: ' + this.opcode + ', fin: ' + this.fin + ', length: ' + this.length + ', hasPayload: ' + Boolean(this.binaryPayload) + ', masked: ' + this.mask;\n};\n\n\nmodule.exports = WebSocketFrame;\n"]},"metadata":{},"sourceType":"script"}