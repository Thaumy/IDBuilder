{"ast":null,"code":"'use strict';\n\nconst {\n  Duplex\n} = require('stream');\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\n\n\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\n\n\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\n\n\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\n\n\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n  const duplex = new Duplex({ ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n  ws.on('message', function message(msg, isBinary) {\n    const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n    if (!duplex.push(data)) ws.pause();\n  });\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return; // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    } // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n\n\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;","map":{"version":3,"sources":["/home/thaumy/Desktop/idb5-ui/node_modules/ws/lib/stream.js"],"names":["Duplex","require","emitClose","stream","emit","duplexOnEnd","destroyed","_writableState","finished","destroy","duplexOnError","err","removeListener","listenerCount","createWebSocketStream","ws","options","terminateOnDestroy","duplex","autoDestroy","objectMode","writableObjectMode","on","message","msg","isBinary","data","_readableState","toString","push","pause","once","error","close","_destroy","callback","readyState","CLOSED","process","nextTick","called","terminate","_final","CONNECTING","open","_socket","endEmitted","finish","_read","isPaused","resume","_write","chunk","encoding","send","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { Duplex } = require('stream');\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg, isBinary) {\n    const data =\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) ws.pause();\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n"]},"metadata":{},"sourceType":"script"}