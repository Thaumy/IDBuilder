{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\n/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\nvar utils = require('./utils');\n\nvar extend = utils.extend;\n\nvar util = require('util');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar url = require('url');\n\nvar crypto = require('crypto');\n\nvar WebSocketConnection = require('./WebSocketConnection');\n\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\nvar protocolSeparators = ['(', ')', '<', '>', '@', ',', ';', ':', '\\\\', '\\\"', '/', '[', ']', '?', '=', '{', '}', ' ', String.fromCharCode(9)];\nvar excludedTlsOptions = ['hostname', 'port', 'method', 'path', 'headers'];\n\nfunction WebSocketClient(config) {\n  // Superclass Constructor\n  EventEmitter.call(this); // TODO: Implement extensions\n\n  this.config = {\n    // 1MiB max frame size.\n    maxReceivedFrameSize: 0x100000,\n    // 8MiB max message size, only applicable if\n    // assembleFragments is true\n    maxReceivedMessageSize: 0x800000,\n    // Outgoing messages larger than fragmentationThreshold will be\n    // split into multiple fragments.\n    fragmentOutgoingMessages: true,\n    // Outgoing frames are fragmented if they exceed this threshold.\n    // Default is 16KiB\n    fragmentationThreshold: 0x4000,\n    // Which version of the protocol to use for this session.  This\n    // option will be removed once the protocol is finalized by the IETF\n    // It is only available to ease the transition through the\n    // intermediate draft protocol versions.\n    // At present, it only affects the name of the Origin header.\n    webSocketVersion: 13,\n    // If true, fragmented messages will be automatically assembled\n    // and the full message will be emitted via a 'message' event.\n    // If false, each frame will be emitted via a 'frame' event and\n    // the application will be responsible for aggregating multiple\n    // fragmented frames.  Single-frame messages will emit a 'message'\n    // event in addition to the 'frame' event.\n    // Most users will want to leave this set to 'true'\n    assembleFragments: true,\n    // The Nagle Algorithm makes more efficient use of network resources\n    // by introducing a small delay before sending small packets so that\n    // multiple messages can be batched together before going onto the\n    // wire.  This however comes at the cost of latency, so the default\n    // is to disable it.  If you don't need low latency and are streaming\n    // lots of small messages, you can change this to 'false'\n    disableNagleAlgorithm: true,\n    // The number of milliseconds to wait after sending a close frame\n    // for an acknowledgement to come back before giving up and just\n    // closing the socket.\n    closeTimeout: 5000,\n    // Options to pass to https.connect if connecting via TLS\n    tlsOptions: {}\n  };\n\n  if (config) {\n    var tlsOptions;\n\n    if (config.tlsOptions) {\n      tlsOptions = config.tlsOptions;\n      delete config.tlsOptions;\n    } else {\n      tlsOptions = {};\n    }\n\n    extend(this.config, config);\n    extend(this.config.tlsOptions, tlsOptions);\n  }\n\n  this._req = null;\n\n  switch (this.config.webSocketVersion) {\n    case 8:\n    case 13:\n      break;\n\n    default:\n      throw new Error('Requested webSocketVersion is not supported. Allowed values are 8 and 13.');\n  }\n}\n\nutil.inherits(WebSocketClient, EventEmitter);\n\nWebSocketClient.prototype.connect = function (requestUrl, protocols, origin, headers, extraRequestOptions) {\n  var self = this;\n\n  if (typeof protocols === 'string') {\n    if (protocols.length > 0) {\n      protocols = [protocols];\n    } else {\n      protocols = [];\n    }\n  }\n\n  if (!(protocols instanceof Array)) {\n    protocols = [];\n  }\n\n  this.protocols = protocols;\n  this.origin = origin;\n\n  if (typeof requestUrl === 'string') {\n    this.url = url.parse(requestUrl);\n  } else {\n    this.url = requestUrl; // in case an already parsed url is passed in.\n  }\n\n  if (!this.url.protocol) {\n    throw new Error('You must specify a full WebSocket URL, including protocol.');\n  }\n\n  if (!this.url.host) {\n    throw new Error('You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.');\n  }\n\n  this.secure = this.url.protocol === 'wss:'; // validate protocol characters:\n\n  this.protocols.forEach(function (protocol) {\n    for (var i = 0; i < protocol.length; i++) {\n      var charCode = protocol.charCodeAt(i);\n      var character = protocol.charAt(i);\n\n      if (charCode < 0x0021 || charCode > 0x007E || protocolSeparators.indexOf(character) !== -1) {\n        throw new Error('Protocol list contains invalid character \"' + String.fromCharCode(charCode) + '\"');\n      }\n    }\n  });\n  var defaultPorts = {\n    'ws:': '80',\n    'wss:': '443'\n  };\n\n  if (!this.url.port) {\n    this.url.port = defaultPorts[this.url.protocol];\n  }\n\n  var nonce = bufferAllocUnsafe(16);\n\n  for (var i = 0; i < 16; i++) {\n    nonce[i] = Math.round(Math.random() * 0xFF);\n  }\n\n  this.base64nonce = nonce.toString('base64');\n  var hostHeaderValue = this.url.hostname;\n\n  if (this.url.protocol === 'ws:' && this.url.port !== '80' || this.url.protocol === 'wss:' && this.url.port !== '443') {\n    hostHeaderValue += ':' + this.url.port;\n  }\n\n  var reqHeaders = {};\n\n  if (this.secure && this.config.tlsOptions.hasOwnProperty('headers')) {\n    // Allow for additional headers to be provided when connecting via HTTPS\n    extend(reqHeaders, this.config.tlsOptions.headers);\n  }\n\n  if (headers) {\n    // Explicitly provided headers take priority over any from tlsOptions\n    extend(reqHeaders, headers);\n  }\n\n  extend(reqHeaders, {\n    'Upgrade': 'websocket',\n    'Connection': 'Upgrade',\n    'Sec-WebSocket-Version': this.config.webSocketVersion.toString(10),\n    'Sec-WebSocket-Key': this.base64nonce,\n    'Host': reqHeaders.Host || hostHeaderValue\n  });\n\n  if (this.protocols.length > 0) {\n    reqHeaders['Sec-WebSocket-Protocol'] = this.protocols.join(', ');\n  }\n\n  if (this.origin) {\n    if (this.config.webSocketVersion === 13) {\n      reqHeaders['Origin'] = this.origin;\n    } else if (this.config.webSocketVersion === 8) {\n      reqHeaders['Sec-WebSocket-Origin'] = this.origin;\n    }\n  } // TODO: Implement extensions\n\n\n  var pathAndQuery; // Ensure it begins with '/'.\n\n  if (this.url.pathname) {\n    pathAndQuery = this.url.path;\n  } else if (this.url.path) {\n    pathAndQuery = '/' + this.url.path;\n  } else {\n    pathAndQuery = '/';\n  }\n\n  function handleRequestError(error) {\n    self._req = null;\n    self.emit('connectFailed', error);\n  }\n\n  var requestOptions = {\n    agent: false\n  };\n\n  if (extraRequestOptions) {\n    extend(requestOptions, extraRequestOptions);\n  } // These options are always overridden by the library.  The user is not\n  // allowed to specify these directly.\n\n\n  extend(requestOptions, {\n    hostname: this.url.hostname,\n    port: this.url.port,\n    method: 'GET',\n    path: pathAndQuery,\n    headers: reqHeaders\n  });\n\n  if (this.secure) {\n    var tlsOptions = this.config.tlsOptions;\n\n    for (var key in tlsOptions) {\n      if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {\n        requestOptions[key] = tlsOptions[key];\n      }\n    }\n  }\n\n  var req = this._req = (this.secure ? https : http).request(requestOptions);\n  req.on('upgrade', function handleRequestUpgrade(response, socket, head) {\n    self._req = null;\n    req.removeListener('error', handleRequestError);\n    self.socket = socket;\n    self.response = response;\n    self.firstDataChunk = head;\n    self.validateHandshake();\n  });\n  req.on('error', handleRequestError);\n  req.on('response', function (response) {\n    self._req = null;\n\n    if (utils.eventEmitterListenerCount(self, 'httpResponse') > 0) {\n      self.emit('httpResponse', response, self);\n\n      if (response.socket) {\n        response.socket.end();\n      }\n    } else {\n      var headerDumpParts = [];\n\n      for (var headerName in response.headers) {\n        headerDumpParts.push(headerName + ': ' + response.headers[headerName]);\n      }\n\n      self.failHandshake('Server responded with a non-101 status: ' + response.statusCode + ' ' + response.statusMessage + '\\nResponse Headers Follow:\\n' + headerDumpParts.join('\\n') + '\\n');\n    }\n  });\n  req.end();\n};\n\nWebSocketClient.prototype.validateHandshake = function () {\n  var headers = this.response.headers;\n\n  if (this.protocols.length > 0) {\n    this.protocol = headers['sec-websocket-protocol'];\n\n    if (this.protocol) {\n      if (this.protocols.indexOf(this.protocol) === -1) {\n        this.failHandshake('Server did not respond with a requested protocol.');\n        return;\n      }\n    } else {\n      this.failHandshake('Expected a Sec-WebSocket-Protocol header.');\n      return;\n    }\n  }\n\n  if (!(headers['connection'] && headers['connection'].toLocaleLowerCase() === 'upgrade')) {\n    this.failHandshake('Expected a Connection: Upgrade header from the server');\n    return;\n  }\n\n  if (!(headers['upgrade'] && headers['upgrade'].toLocaleLowerCase() === 'websocket')) {\n    this.failHandshake('Expected an Upgrade: websocket header from the server');\n    return;\n  }\n\n  var sha1 = crypto.createHash('sha1');\n  sha1.update(this.base64nonce + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n  var expectedKey = sha1.digest('base64');\n\n  if (!headers['sec-websocket-accept']) {\n    this.failHandshake('Expected Sec-WebSocket-Accept header from server');\n    return;\n  }\n\n  if (headers['sec-websocket-accept'] !== expectedKey) {\n    this.failHandshake('Sec-WebSocket-Accept header from server didn\\'t match expected value of ' + expectedKey);\n    return;\n  } // TODO: Support extensions\n\n\n  this.succeedHandshake();\n};\n\nWebSocketClient.prototype.failHandshake = function (errorDescription) {\n  if (this.socket && this.socket.writable) {\n    this.socket.end();\n  }\n\n  this.emit('connectFailed', new Error(errorDescription));\n};\n\nWebSocketClient.prototype.succeedHandshake = function () {\n  var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);\n  connection.webSocketVersion = this.config.webSocketVersion;\n\n  connection._addSocketEventListeners();\n\n  this.emit('connect', connection);\n\n  if (this.firstDataChunk.length > 0) {\n    connection.handleSocketData(this.firstDataChunk);\n  }\n\n  this.firstDataChunk = null;\n};\n\nWebSocketClient.prototype.abort = function () {\n  if (this._req) {\n    this._req.abort();\n  }\n};\n\nmodule.exports = WebSocketClient;","map":{"version":3,"sources":["/home/thaumy/Desktop/idb5-ui/node_modules/websocket/lib/WebSocketClient.js"],"names":["utils","require","extend","util","EventEmitter","http","https","url","crypto","WebSocketConnection","bufferAllocUnsafe","protocolSeparators","String","fromCharCode","excludedTlsOptions","WebSocketClient","config","call","maxReceivedFrameSize","maxReceivedMessageSize","fragmentOutgoingMessages","fragmentationThreshold","webSocketVersion","assembleFragments","disableNagleAlgorithm","closeTimeout","tlsOptions","_req","Error","inherits","prototype","connect","requestUrl","protocols","origin","headers","extraRequestOptions","self","length","Array","parse","protocol","host","secure","forEach","i","charCode","charCodeAt","character","charAt","indexOf","defaultPorts","port","nonce","Math","round","random","base64nonce","toString","hostHeaderValue","hostname","reqHeaders","hasOwnProperty","Host","join","pathAndQuery","pathname","path","handleRequestError","error","emit","requestOptions","agent","method","key","req","request","on","handleRequestUpgrade","response","socket","head","removeListener","firstDataChunk","validateHandshake","eventEmitterListenerCount","end","headerDumpParts","headerName","push","failHandshake","statusCode","statusMessage","toLocaleLowerCase","sha1","createHash","update","expectedKey","digest","succeedHandshake","errorDescription","writable","connection","_addSocketEventListeners","handleSocketData","abort","module","exports"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAIC,MAAM,GAAGF,KAAK,CAACE,MAAnB;;AACA,IAAIC,IAAI,GAAGF,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIG,YAAY,GAAGH,OAAO,CAAC,QAAD,CAAP,CAAkBG,YAArC;;AACA,IAAIC,IAAI,GAAGJ,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIK,KAAK,GAAGL,OAAO,CAAC,OAAD,CAAnB;;AACA,IAAIM,GAAG,GAAGN,OAAO,CAAC,KAAD,CAAjB;;AACA,IAAIO,MAAM,GAAGP,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIQ,mBAAmB,GAAGR,OAAO,CAAC,uBAAD,CAAjC;;AACA,IAAIS,iBAAiB,GAAGV,KAAK,CAACU,iBAA9B;AAEA,IAAIC,kBAAkB,GAAG,CACrB,GADqB,EAChB,GADgB,EACX,GADW,EACN,GADM,EACD,GADC,EAErB,GAFqB,EAEhB,GAFgB,EAEX,GAFW,EAEN,IAFM,EAEA,IAFA,EAGrB,GAHqB,EAGhB,GAHgB,EAGX,GAHW,EAGN,GAHM,EAGD,GAHC,EAIrB,GAJqB,EAIhB,GAJgB,EAIX,GAJW,EAINC,MAAM,CAACC,YAAP,CAAoB,CAApB,CAJM,CAAzB;AAOA,IAAIC,kBAAkB,GAAG,CAAC,UAAD,EAAY,MAAZ,EAAmB,QAAnB,EAA4B,MAA5B,EAAmC,SAAnC,CAAzB;;AAEA,SAASC,eAAT,CAAyBC,MAAzB,EAAiC;AAC7B;AACAZ,EAAAA,YAAY,CAACa,IAAb,CAAkB,IAAlB,EAF6B,CAI7B;;AAEA,OAAKD,MAAL,GAAc;AACV;AACAE,IAAAA,oBAAoB,EAAE,QAFZ;AAIV;AACA;AACAC,IAAAA,sBAAsB,EAAE,QANd;AAQV;AACA;AACAC,IAAAA,wBAAwB,EAAE,IAVhB;AAYV;AACA;AACAC,IAAAA,sBAAsB,EAAE,MAdd;AAgBV;AACA;AACA;AACA;AACA;AACAC,IAAAA,gBAAgB,EAAE,EArBR;AAuBV;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,IAAAA,iBAAiB,EAAE,IA9BT;AAgCV;AACA;AACA;AACA;AACA;AACA;AACAC,IAAAA,qBAAqB,EAAE,IAtCb;AAwCV;AACA;AACA;AACAC,IAAAA,YAAY,EAAE,IA3CJ;AA6CV;AACAC,IAAAA,UAAU,EAAE;AA9CF,GAAd;;AAiDA,MAAIV,MAAJ,EAAY;AACR,QAAIU,UAAJ;;AACA,QAAIV,MAAM,CAACU,UAAX,EAAuB;AACrBA,MAAAA,UAAU,GAAGV,MAAM,CAACU,UAApB;AACA,aAAOV,MAAM,CAACU,UAAd;AACD,KAHD,MAIK;AACHA,MAAAA,UAAU,GAAG,EAAb;AACD;;AACDxB,IAAAA,MAAM,CAAC,KAAKc,MAAN,EAAcA,MAAd,CAAN;AACAd,IAAAA,MAAM,CAAC,KAAKc,MAAL,CAAYU,UAAb,EAAyBA,UAAzB,CAAN;AACH;;AAED,OAAKC,IAAL,GAAY,IAAZ;;AAEA,UAAQ,KAAKX,MAAL,CAAYM,gBAApB;AACI,SAAK,CAAL;AACA,SAAK,EAAL;AACI;;AACJ;AACI,YAAM,IAAIM,KAAJ,CAAU,2EAAV,CAAN;AALR;AAOH;;AAEDzB,IAAI,CAAC0B,QAAL,CAAcd,eAAd,EAA+BX,YAA/B;;AAEAW,eAAe,CAACe,SAAhB,CAA0BC,OAA1B,GAAoC,UAASC,UAAT,EAAqBC,SAArB,EAAgCC,MAAhC,EAAwCC,OAAxC,EAAiDC,mBAAjD,EAAsE;AACtG,MAAIC,IAAI,GAAG,IAAX;;AAEA,MAAI,OAAOJ,SAAP,KAAsB,QAA1B,EAAoC;AAChC,QAAIA,SAAS,CAACK,MAAV,GAAmB,CAAvB,EAA0B;AACtBL,MAAAA,SAAS,GAAG,CAACA,SAAD,CAAZ;AACH,KAFD,MAGK;AACDA,MAAAA,SAAS,GAAG,EAAZ;AACH;AACJ;;AACD,MAAI,EAAEA,SAAS,YAAYM,KAAvB,CAAJ,EAAmC;AAC/BN,IAAAA,SAAS,GAAG,EAAZ;AACH;;AACD,OAAKA,SAAL,GAAiBA,SAAjB;AACA,OAAKC,MAAL,GAAcA,MAAd;;AAEA,MAAI,OAAOF,UAAP,KAAuB,QAA3B,EAAqC;AACjC,SAAKzB,GAAL,GAAWA,GAAG,CAACiC,KAAJ,CAAUR,UAAV,CAAX;AACH,GAFD,MAGK;AACD,SAAKzB,GAAL,GAAWyB,UAAX,CADC,CACsB;AAC1B;;AACD,MAAI,CAAC,KAAKzB,GAAL,CAASkC,QAAd,EAAwB;AACpB,UAAM,IAAIb,KAAJ,CAAU,4DAAV,CAAN;AACH;;AACD,MAAI,CAAC,KAAKrB,GAAL,CAASmC,IAAd,EAAoB;AAChB,UAAM,IAAId,KAAJ,CAAU,6FAAV,CAAN;AACH;;AAED,OAAKe,MAAL,GAAe,KAAKpC,GAAL,CAASkC,QAAT,KAAsB,MAArC,CA9BsG,CAgCtG;;AACA,OAAKR,SAAL,CAAeW,OAAf,CAAuB,UAASH,QAAT,EAAmB;AACtC,SAAK,IAAII,CAAC,GAAC,CAAX,EAAcA,CAAC,GAAGJ,QAAQ,CAACH,MAA3B,EAAmCO,CAAC,EAApC,EAAyC;AACrC,UAAIC,QAAQ,GAAGL,QAAQ,CAACM,UAAT,CAAoBF,CAApB,CAAf;AACA,UAAIG,SAAS,GAAGP,QAAQ,CAACQ,MAAT,CAAgBJ,CAAhB,CAAhB;;AACA,UAAIC,QAAQ,GAAG,MAAX,IAAqBA,QAAQ,GAAG,MAAhC,IAA0CnC,kBAAkB,CAACuC,OAAnB,CAA2BF,SAA3B,MAA0C,CAAC,CAAzF,EAA4F;AACxF,cAAM,IAAIpB,KAAJ,CAAU,+CAA+ChB,MAAM,CAACC,YAAP,CAAoBiC,QAApB,CAA/C,GAA+E,GAAzF,CAAN;AACH;AACJ;AACJ,GARD;AAUA,MAAIK,YAAY,GAAG;AACf,WAAO,IADQ;AAEf,YAAQ;AAFO,GAAnB;;AAKA,MAAI,CAAC,KAAK5C,GAAL,CAAS6C,IAAd,EAAoB;AAChB,SAAK7C,GAAL,CAAS6C,IAAT,GAAgBD,YAAY,CAAC,KAAK5C,GAAL,CAASkC,QAAV,CAA5B;AACH;;AAED,MAAIY,KAAK,GAAG3C,iBAAiB,CAAC,EAAD,CAA7B;;AACA,OAAK,IAAImC,CAAC,GAAC,CAAX,EAAcA,CAAC,GAAG,EAAlB,EAAsBA,CAAC,EAAvB,EAA2B;AACvBQ,IAAAA,KAAK,CAACR,CAAD,CAAL,GAAWS,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAc,IAAzB,CAAX;AACH;;AACD,OAAKC,WAAL,GAAmBJ,KAAK,CAACK,QAAN,CAAe,QAAf,CAAnB;AAEA,MAAIC,eAAe,GAAG,KAAKpD,GAAL,CAASqD,QAA/B;;AACA,MAAK,KAAKrD,GAAL,CAASkC,QAAT,KAAsB,KAAtB,IAA+B,KAAKlC,GAAL,CAAS6C,IAAT,KAAkB,IAAlD,IACC,KAAK7C,GAAL,CAASkC,QAAT,KAAsB,MAAtB,IAAgC,KAAKlC,GAAL,CAAS6C,IAAT,KAAkB,KADvD,EACgE;AAC5DO,IAAAA,eAAe,IAAK,MAAM,KAAKpD,GAAL,CAAS6C,IAAnC;AACH;;AAED,MAAIS,UAAU,GAAG,EAAjB;;AACA,MAAI,KAAKlB,MAAL,IAAe,KAAK3B,MAAL,CAAYU,UAAZ,CAAuBoC,cAAvB,CAAsC,SAAtC,CAAnB,EAAqE;AACnE;AACA5D,IAAAA,MAAM,CAAC2D,UAAD,EAAa,KAAK7C,MAAL,CAAYU,UAAZ,CAAuBS,OAApC,CAAN;AACD;;AACD,MAAIA,OAAJ,EAAa;AACX;AACAjC,IAAAA,MAAM,CAAC2D,UAAD,EAAa1B,OAAb,CAAN;AACD;;AACDjC,EAAAA,MAAM,CAAC2D,UAAD,EAAa;AACf,eAAW,WADI;AAEf,kBAAc,SAFC;AAGf,6BAAyB,KAAK7C,MAAL,CAAYM,gBAAZ,CAA6BoC,QAA7B,CAAsC,EAAtC,CAHV;AAIf,yBAAqB,KAAKD,WAJX;AAKf,YAAQI,UAAU,CAACE,IAAX,IAAmBJ;AALZ,GAAb,CAAN;;AAQA,MAAI,KAAK1B,SAAL,CAAeK,MAAf,GAAwB,CAA5B,EAA+B;AAC3BuB,IAAAA,UAAU,CAAC,wBAAD,CAAV,GAAuC,KAAK5B,SAAL,CAAe+B,IAAf,CAAoB,IAApB,CAAvC;AACH;;AACD,MAAI,KAAK9B,MAAT,EAAiB;AACb,QAAI,KAAKlB,MAAL,CAAYM,gBAAZ,KAAiC,EAArC,EAAyC;AACrCuC,MAAAA,UAAU,CAAC,QAAD,CAAV,GAAuB,KAAK3B,MAA5B;AACH,KAFD,MAGK,IAAI,KAAKlB,MAAL,CAAYM,gBAAZ,KAAiC,CAArC,EAAwC;AACzCuC,MAAAA,UAAU,CAAC,sBAAD,CAAV,GAAqC,KAAK3B,MAA1C;AACH;AACJ,GA3FqG,CA6FtG;;;AAEA,MAAI+B,YAAJ,CA/FsG,CAgGtG;;AACA,MAAI,KAAK1D,GAAL,CAAS2D,QAAb,EAAuB;AACnBD,IAAAA,YAAY,GAAG,KAAK1D,GAAL,CAAS4D,IAAxB;AACH,GAFD,MAGK,IAAI,KAAK5D,GAAL,CAAS4D,IAAb,EAAmB;AACpBF,IAAAA,YAAY,GAAG,MAAM,KAAK1D,GAAL,CAAS4D,IAA9B;AACH,GAFI,MAGA;AACDF,IAAAA,YAAY,GAAG,GAAf;AACH;;AAED,WAASG,kBAAT,CAA4BC,KAA5B,EAAmC;AAC/BhC,IAAAA,IAAI,CAACV,IAAL,GAAY,IAAZ;AACAU,IAAAA,IAAI,CAACiC,IAAL,CAAU,eAAV,EAA2BD,KAA3B;AACH;;AAED,MAAIE,cAAc,GAAG;AACjBC,IAAAA,KAAK,EAAE;AADU,GAArB;;AAGA,MAAIpC,mBAAJ,EAAyB;AACrBlC,IAAAA,MAAM,CAACqE,cAAD,EAAiBnC,mBAAjB,CAAN;AACH,GArHqG,CAsHtG;AACA;;;AACAlC,EAAAA,MAAM,CAACqE,cAAD,EAAiB;AACnBX,IAAAA,QAAQ,EAAE,KAAKrD,GAAL,CAASqD,QADA;AAEnBR,IAAAA,IAAI,EAAE,KAAK7C,GAAL,CAAS6C,IAFI;AAGnBqB,IAAAA,MAAM,EAAE,KAHW;AAInBN,IAAAA,IAAI,EAAEF,YAJa;AAKnB9B,IAAAA,OAAO,EAAE0B;AALU,GAAjB,CAAN;;AAOA,MAAI,KAAKlB,MAAT,EAAiB;AACb,QAAIjB,UAAU,GAAG,KAAKV,MAAL,CAAYU,UAA7B;;AACA,SAAK,IAAIgD,GAAT,IAAgBhD,UAAhB,EAA4B;AACxB,UAAIA,UAAU,CAACoC,cAAX,CAA0BY,GAA1B,KAAkC5D,kBAAkB,CAACoC,OAAnB,CAA2BwB,GAA3B,MAAoC,CAAC,CAA3E,EAA8E;AAC1EH,QAAAA,cAAc,CAACG,GAAD,CAAd,GAAsBhD,UAAU,CAACgD,GAAD,CAAhC;AACH;AACJ;AACJ;;AAED,MAAIC,GAAG,GAAG,KAAKhD,IAAL,GAAY,CAAC,KAAKgB,MAAL,GAAcrC,KAAd,GAAsBD,IAAvB,EAA6BuE,OAA7B,CAAqCL,cAArC,CAAtB;AACAI,EAAAA,GAAG,CAACE,EAAJ,CAAO,SAAP,EAAkB,SAASC,oBAAT,CAA8BC,QAA9B,EAAwCC,MAAxC,EAAgDC,IAAhD,EAAsD;AACpE5C,IAAAA,IAAI,CAACV,IAAL,GAAY,IAAZ;AACAgD,IAAAA,GAAG,CAACO,cAAJ,CAAmB,OAAnB,EAA4Bd,kBAA5B;AACA/B,IAAAA,IAAI,CAAC2C,MAAL,GAAcA,MAAd;AACA3C,IAAAA,IAAI,CAAC0C,QAAL,GAAgBA,QAAhB;AACA1C,IAAAA,IAAI,CAAC8C,cAAL,GAAsBF,IAAtB;AACA5C,IAAAA,IAAI,CAAC+C,iBAAL;AACH,GAPD;AAQAT,EAAAA,GAAG,CAACE,EAAJ,CAAO,OAAP,EAAgBT,kBAAhB;AAEAO,EAAAA,GAAG,CAACE,EAAJ,CAAO,UAAP,EAAmB,UAASE,QAAT,EAAmB;AAClC1C,IAAAA,IAAI,CAACV,IAAL,GAAY,IAAZ;;AACA,QAAI3B,KAAK,CAACqF,yBAAN,CAAgChD,IAAhC,EAAsC,cAAtC,IAAwD,CAA5D,EAA+D;AAC3DA,MAAAA,IAAI,CAACiC,IAAL,CAAU,cAAV,EAA0BS,QAA1B,EAAoC1C,IAApC;;AACA,UAAI0C,QAAQ,CAACC,MAAb,EAAqB;AACjBD,QAAAA,QAAQ,CAACC,MAAT,CAAgBM,GAAhB;AACH;AACJ,KALD,MAMK;AACD,UAAIC,eAAe,GAAG,EAAtB;;AACA,WAAK,IAAIC,UAAT,IAAuBT,QAAQ,CAAC5C,OAAhC,EAAyC;AACrCoD,QAAAA,eAAe,CAACE,IAAhB,CAAqBD,UAAU,GAAG,IAAb,GAAoBT,QAAQ,CAAC5C,OAAT,CAAiBqD,UAAjB,CAAzC;AACH;;AACDnD,MAAAA,IAAI,CAACqD,aAAL,CACI,6CACAX,QAAQ,CAACY,UADT,GACsB,GADtB,GAC4BZ,QAAQ,CAACa,aADrC,GAEA,8BAFA,GAGAL,eAAe,CAACvB,IAAhB,CAAqB,IAArB,CAHA,GAG6B,IAJjC;AAMH;AACJ,GApBD;AAqBAW,EAAAA,GAAG,CAACW,GAAJ;AACH,CAzKD;;AA2KAvE,eAAe,CAACe,SAAhB,CAA0BsD,iBAA1B,GAA8C,YAAW;AACrD,MAAIjD,OAAO,GAAG,KAAK4C,QAAL,CAAc5C,OAA5B;;AAEA,MAAI,KAAKF,SAAL,CAAeK,MAAf,GAAwB,CAA5B,EAA+B;AAC3B,SAAKG,QAAL,GAAgBN,OAAO,CAAC,wBAAD,CAAvB;;AACA,QAAI,KAAKM,QAAT,EAAmB;AACf,UAAI,KAAKR,SAAL,CAAeiB,OAAf,CAAuB,KAAKT,QAA5B,MAA0C,CAAC,CAA/C,EAAkD;AAC9C,aAAKiD,aAAL,CAAmB,mDAAnB;AACA;AACH;AACJ,KALD,MAMK;AACD,WAAKA,aAAL,CAAmB,2CAAnB;AACA;AACH;AACJ;;AAED,MAAI,EAAEvD,OAAO,CAAC,YAAD,CAAP,IAAyBA,OAAO,CAAC,YAAD,CAAP,CAAsB0D,iBAAtB,OAA8C,SAAzE,CAAJ,EAAyF;AACrF,SAAKH,aAAL,CAAmB,uDAAnB;AACA;AACH;;AAED,MAAI,EAAEvD,OAAO,CAAC,SAAD,CAAP,IAAsBA,OAAO,CAAC,SAAD,CAAP,CAAmB0D,iBAAnB,OAA2C,WAAnE,CAAJ,EAAqF;AACjF,SAAKH,aAAL,CAAmB,uDAAnB;AACA;AACH;;AAED,MAAII,IAAI,GAAGtF,MAAM,CAACuF,UAAP,CAAkB,MAAlB,CAAX;AACAD,EAAAA,IAAI,CAACE,MAAL,CAAY,KAAKvC,WAAL,GAAmB,sCAA/B;AACA,MAAIwC,WAAW,GAAGH,IAAI,CAACI,MAAL,CAAY,QAAZ,CAAlB;;AAEA,MAAI,CAAC/D,OAAO,CAAC,sBAAD,CAAZ,EAAsC;AAClC,SAAKuD,aAAL,CAAmB,kDAAnB;AACA;AACH;;AAED,MAAIvD,OAAO,CAAC,sBAAD,CAAP,KAAoC8D,WAAxC,EAAqD;AACjD,SAAKP,aAAL,CAAmB,6EAA6EO,WAAhG;AACA;AACH,GAvCoD,CAyCrD;;;AAEA,OAAKE,gBAAL;AACH,CA5CD;;AA8CApF,eAAe,CAACe,SAAhB,CAA0B4D,aAA1B,GAA0C,UAASU,gBAAT,EAA2B;AACjE,MAAI,KAAKpB,MAAL,IAAe,KAAKA,MAAL,CAAYqB,QAA/B,EAAyC;AACrC,SAAKrB,MAAL,CAAYM,GAAZ;AACH;;AACD,OAAKhB,IAAL,CAAU,eAAV,EAA2B,IAAI1C,KAAJ,CAAUwE,gBAAV,CAA3B;AACH,CALD;;AAOArF,eAAe,CAACe,SAAhB,CAA0BqE,gBAA1B,GAA6C,YAAW;AACpD,MAAIG,UAAU,GAAG,IAAI7F,mBAAJ,CAAwB,KAAKuE,MAA7B,EAAqC,EAArC,EAAyC,KAAKvC,QAA9C,EAAwD,IAAxD,EAA8D,KAAKzB,MAAnE,CAAjB;AAEAsF,EAAAA,UAAU,CAAChF,gBAAX,GAA8B,KAAKN,MAAL,CAAYM,gBAA1C;;AACAgF,EAAAA,UAAU,CAACC,wBAAX;;AAEA,OAAKjC,IAAL,CAAU,SAAV,EAAqBgC,UAArB;;AACA,MAAI,KAAKnB,cAAL,CAAoB7C,MAApB,GAA6B,CAAjC,EAAoC;AAChCgE,IAAAA,UAAU,CAACE,gBAAX,CAA4B,KAAKrB,cAAjC;AACH;;AACD,OAAKA,cAAL,GAAsB,IAAtB;AACH,CAXD;;AAaApE,eAAe,CAACe,SAAhB,CAA0B2E,KAA1B,GAAkC,YAAW;AACzC,MAAI,KAAK9E,IAAT,EAAe;AACX,SAAKA,IAAL,CAAU8E,KAAV;AACH;AACJ,CAJD;;AAMAC,MAAM,CAACC,OAAP,GAAiB5F,eAAjB","sourcesContent":["/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar utils = require('./utils');\nvar extend = utils.extend;\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar http = require('http');\nvar https = require('https');\nvar url = require('url');\nvar crypto = require('crypto');\nvar WebSocketConnection = require('./WebSocketConnection');\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\n\nvar protocolSeparators = [\n    '(', ')', '<', '>', '@',\n    ',', ';', ':', '\\\\', '\\\"',\n    '/', '[', ']', '?', '=',\n    '{', '}', ' ', String.fromCharCode(9)\n];\n\nvar excludedTlsOptions = ['hostname','port','method','path','headers'];\n\nfunction WebSocketClient(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    // TODO: Implement extensions\n\n    this.config = {\n        // 1MiB max frame size.\n        maxReceivedFrameSize: 0x100000,\n\n        // 8MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x800000,\n\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n\n        // Which version of the protocol to use for this session.  This\n        // option will be removed once the protocol is finalized by the IETF\n        // It is only available to ease the transition through the\n        // intermediate draft protocol versions.\n        // At present, it only affects the name of the Origin header.\n        webSocketVersion: 13,\n\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000,\n\n        // Options to pass to https.connect if connecting via TLS\n        tlsOptions: {}\n    };\n\n    if (config) {\n        var tlsOptions;\n        if (config.tlsOptions) {\n          tlsOptions = config.tlsOptions;\n          delete config.tlsOptions;\n        }\n        else {\n          tlsOptions = {};\n        }\n        extend(this.config, config);\n        extend(this.config.tlsOptions, tlsOptions);\n    }\n\n    this._req = null;\n    \n    switch (this.config.webSocketVersion) {\n        case 8:\n        case 13:\n            break;\n        default:\n            throw new Error('Requested webSocketVersion is not supported. Allowed values are 8 and 13.');\n    }\n}\n\nutil.inherits(WebSocketClient, EventEmitter);\n\nWebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {\n    var self = this;\n    \n    if (typeof(protocols) === 'string') {\n        if (protocols.length > 0) {\n            protocols = [protocols];\n        }\n        else {\n            protocols = [];\n        }\n    }\n    if (!(protocols instanceof Array)) {\n        protocols = [];\n    }\n    this.protocols = protocols;\n    this.origin = origin;\n\n    if (typeof(requestUrl) === 'string') {\n        this.url = url.parse(requestUrl);\n    }\n    else {\n        this.url = requestUrl; // in case an already parsed url is passed in.\n    }\n    if (!this.url.protocol) {\n        throw new Error('You must specify a full WebSocket URL, including protocol.');\n    }\n    if (!this.url.host) {\n        throw new Error('You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.');\n    }\n\n    this.secure = (this.url.protocol === 'wss:');\n\n    // validate protocol characters:\n    this.protocols.forEach(function(protocol) {\n        for (var i=0; i < protocol.length; i ++) {\n            var charCode = protocol.charCodeAt(i);\n            var character = protocol.charAt(i);\n            if (charCode < 0x0021 || charCode > 0x007E || protocolSeparators.indexOf(character) !== -1) {\n                throw new Error('Protocol list contains invalid character \"' + String.fromCharCode(charCode) + '\"');\n            }\n        }\n    });\n\n    var defaultPorts = {\n        'ws:': '80',\n        'wss:': '443'\n    };\n\n    if (!this.url.port) {\n        this.url.port = defaultPorts[this.url.protocol];\n    }\n\n    var nonce = bufferAllocUnsafe(16);\n    for (var i=0; i < 16; i++) {\n        nonce[i] = Math.round(Math.random()*0xFF);\n    }\n    this.base64nonce = nonce.toString('base64');\n\n    var hostHeaderValue = this.url.hostname;\n    if ((this.url.protocol === 'ws:' && this.url.port !== '80') ||\n        (this.url.protocol === 'wss:' && this.url.port !== '443'))  {\n        hostHeaderValue += (':' + this.url.port);\n    }\n\n    var reqHeaders = {};\n    if (this.secure && this.config.tlsOptions.hasOwnProperty('headers')) {\n      // Allow for additional headers to be provided when connecting via HTTPS\n      extend(reqHeaders, this.config.tlsOptions.headers);\n    }\n    if (headers) {\n      // Explicitly provided headers take priority over any from tlsOptions\n      extend(reqHeaders, headers);\n    }\n    extend(reqHeaders, {\n        'Upgrade': 'websocket',\n        'Connection': 'Upgrade',\n        'Sec-WebSocket-Version': this.config.webSocketVersion.toString(10),\n        'Sec-WebSocket-Key': this.base64nonce,\n        'Host': reqHeaders.Host || hostHeaderValue\n    });\n\n    if (this.protocols.length > 0) {\n        reqHeaders['Sec-WebSocket-Protocol'] = this.protocols.join(', ');\n    }\n    if (this.origin) {\n        if (this.config.webSocketVersion === 13) {\n            reqHeaders['Origin'] = this.origin;\n        }\n        else if (this.config.webSocketVersion === 8) {\n            reqHeaders['Sec-WebSocket-Origin'] = this.origin;\n        }\n    }\n\n    // TODO: Implement extensions\n\n    var pathAndQuery;\n    // Ensure it begins with '/'.\n    if (this.url.pathname) {\n        pathAndQuery = this.url.path;\n    }\n    else if (this.url.path) {\n        pathAndQuery = '/' + this.url.path;\n    }\n    else {\n        pathAndQuery = '/';\n    }\n\n    function handleRequestError(error) {\n        self._req = null;\n        self.emit('connectFailed', error);\n    }\n\n    var requestOptions = {\n        agent: false\n    };\n    if (extraRequestOptions) {\n        extend(requestOptions, extraRequestOptions);\n    }\n    // These options are always overridden by the library.  The user is not\n    // allowed to specify these directly.\n    extend(requestOptions, {\n        hostname: this.url.hostname,\n        port: this.url.port,\n        method: 'GET',\n        path: pathAndQuery,\n        headers: reqHeaders\n    });\n    if (this.secure) {\n        var tlsOptions = this.config.tlsOptions;\n        for (var key in tlsOptions) {\n            if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {\n                requestOptions[key] = tlsOptions[key];\n            }\n        }\n    }\n\n    var req = this._req = (this.secure ? https : http).request(requestOptions);\n    req.on('upgrade', function handleRequestUpgrade(response, socket, head) {\n        self._req = null;\n        req.removeListener('error', handleRequestError);\n        self.socket = socket;\n        self.response = response;\n        self.firstDataChunk = head;\n        self.validateHandshake();\n    });\n    req.on('error', handleRequestError);\n\n    req.on('response', function(response) {\n        self._req = null;\n        if (utils.eventEmitterListenerCount(self, 'httpResponse') > 0) {\n            self.emit('httpResponse', response, self);\n            if (response.socket) {\n                response.socket.end();\n            }\n        }\n        else {\n            var headerDumpParts = [];\n            for (var headerName in response.headers) {\n                headerDumpParts.push(headerName + ': ' + response.headers[headerName]);\n            }\n            self.failHandshake(\n                'Server responded with a non-101 status: ' +\n                response.statusCode + ' ' + response.statusMessage +\n                '\\nResponse Headers Follow:\\n' +\n                headerDumpParts.join('\\n') + '\\n'\n            );\n        }\n    });\n    req.end();\n};\n\nWebSocketClient.prototype.validateHandshake = function() {\n    var headers = this.response.headers;\n\n    if (this.protocols.length > 0) {\n        this.protocol = headers['sec-websocket-protocol'];\n        if (this.protocol) {\n            if (this.protocols.indexOf(this.protocol) === -1) {\n                this.failHandshake('Server did not respond with a requested protocol.');\n                return;\n            }\n        }\n        else {\n            this.failHandshake('Expected a Sec-WebSocket-Protocol header.');\n            return;\n        }\n    }\n\n    if (!(headers['connection'] && headers['connection'].toLocaleLowerCase() === 'upgrade')) {\n        this.failHandshake('Expected a Connection: Upgrade header from the server');\n        return;\n    }\n\n    if (!(headers['upgrade'] && headers['upgrade'].toLocaleLowerCase() === 'websocket')) {\n        this.failHandshake('Expected an Upgrade: websocket header from the server');\n        return;\n    }\n\n    var sha1 = crypto.createHash('sha1');\n    sha1.update(this.base64nonce + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n    var expectedKey = sha1.digest('base64');\n\n    if (!headers['sec-websocket-accept']) {\n        this.failHandshake('Expected Sec-WebSocket-Accept header from server');\n        return;\n    }\n\n    if (headers['sec-websocket-accept'] !== expectedKey) {\n        this.failHandshake('Sec-WebSocket-Accept header from server didn\\'t match expected value of ' + expectedKey);\n        return;\n    }\n\n    // TODO: Support extensions\n\n    this.succeedHandshake();\n};\n\nWebSocketClient.prototype.failHandshake = function(errorDescription) {\n    if (this.socket && this.socket.writable) {\n        this.socket.end();\n    }\n    this.emit('connectFailed', new Error(errorDescription));\n};\n\nWebSocketClient.prototype.succeedHandshake = function() {\n    var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);\n\n    connection.webSocketVersion = this.config.webSocketVersion;\n    connection._addSocketEventListeners();\n\n    this.emit('connect', connection);\n    if (this.firstDataChunk.length > 0) {\n        connection.handleSocketData(this.firstDataChunk);\n    }\n    this.firstDataChunk = null;\n};\n\nWebSocketClient.prototype.abort = function() {\n    if (this._req) {\n        this._req.abort();\n    }\n};\n\nmodule.exports = WebSocketClient;\n"]},"metadata":{},"sourceType":"script"}