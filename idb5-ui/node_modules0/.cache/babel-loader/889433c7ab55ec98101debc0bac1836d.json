{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\n/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\nvar extend = require('./utils').extend;\n\nvar utils = require('./utils');\n\nvar util = require('util');\n\nvar debug = require('debug')('websocket:server');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar WebSocketRequest = require('./WebSocketRequest');\n\nvar WebSocketServer = function WebSocketServer(config) {\n  // Superclass Constructor\n  EventEmitter.call(this);\n  this._handlers = {\n    upgrade: this.handleUpgrade.bind(this),\n    requestAccepted: this.handleRequestAccepted.bind(this),\n    requestResolved: this.handleRequestResolved.bind(this)\n  };\n  this.connections = [];\n  this.pendingRequests = [];\n\n  if (config) {\n    this.mount(config);\n  }\n};\n\nutil.inherits(WebSocketServer, EventEmitter);\n\nWebSocketServer.prototype.mount = function (config) {\n  this.config = {\n    // The http server instance to attach to.  Required.\n    httpServer: null,\n    // 64KiB max frame size.\n    maxReceivedFrameSize: 0x10000,\n    // 1MiB max message size, only applicable if\n    // assembleFragments is true\n    maxReceivedMessageSize: 0x100000,\n    // Outgoing messages larger than fragmentationThreshold will be\n    // split into multiple fragments.\n    fragmentOutgoingMessages: true,\n    // Outgoing frames are fragmented if they exceed this threshold.\n    // Default is 16KiB\n    fragmentationThreshold: 0x4000,\n    // If true, the server will automatically send a ping to all\n    // clients every 'keepaliveInterval' milliseconds.  The timer is\n    // reset on any received data from the client.\n    keepalive: true,\n    // The interval to send keepalive pings to connected clients if the\n    // connection is idle.  Any received data will reset the counter.\n    keepaliveInterval: 20000,\n    // If true, the server will consider any connection that has not\n    // received any data within the amount of time specified by\n    // 'keepaliveGracePeriod' after a keepalive ping has been sent to\n    // be dead, and will drop the connection.\n    // Ignored if keepalive is false.\n    dropConnectionOnKeepaliveTimeout: true,\n    // The amount of time to wait after sending a keepalive ping before\n    // closing the connection if the connected peer does not respond.\n    // Ignored if keepalive is false.\n    keepaliveGracePeriod: 10000,\n    // Whether to use native TCP keep-alive instead of WebSockets ping\n    // and pong packets.  Native TCP keep-alive sends smaller packets\n    // on the wire and so uses bandwidth more efficiently.  This may\n    // be more important when talking to mobile devices.\n    // If this value is set to true, then these values will be ignored:\n    //   keepaliveGracePeriod\n    //   dropConnectionOnKeepaliveTimeout\n    useNativeKeepalive: false,\n    // If true, fragmented messages will be automatically assembled\n    // and the full message will be emitted via a 'message' event.\n    // If false, each frame will be emitted via a 'frame' event and\n    // the application will be responsible for aggregating multiple\n    // fragmented frames.  Single-frame messages will emit a 'message'\n    // event in addition to the 'frame' event.\n    // Most users will want to leave this set to 'true'\n    assembleFragments: true,\n    // If this is true, websocket connections will be accepted\n    // regardless of the path and protocol specified by the client.\n    // The protocol accepted will be the first that was requested\n    // by the client.  Clients from any origin will be accepted.\n    // This should only be used in the simplest of cases.  You should\n    // probably leave this set to 'false' and inspect the request\n    // object to make sure it's acceptable before accepting it.\n    autoAcceptConnections: false,\n    // Whether or not the X-Forwarded-For header should be respected.\n    // It's important to set this to 'true' when accepting connections\n    // from untrusted clients, as a malicious client could spoof its\n    // IP address by simply setting this header.  It's meant to be added\n    // by a trusted proxy or other intermediary within your own\n    // infrastructure.\n    // See:  http://en.wikipedia.org/wiki/X-Forwarded-For\n    ignoreXForwardedFor: false,\n    // If this is true, 'cookie' headers are parsed and exposed as WebSocketRequest.cookies\n    parseCookies: true,\n    // If this is true, 'sec-websocket-extensions' headers are parsed and exposed as WebSocketRequest.requestedExtensions\n    parseExtensions: true,\n    // The Nagle Algorithm makes more efficient use of network resources\n    // by introducing a small delay before sending small packets so that\n    // multiple messages can be batched together before going onto the\n    // wire.  This however comes at the cost of latency, so the default\n    // is to disable it.  If you don't need low latency and are streaming\n    // lots of small messages, you can change this to 'false'\n    disableNagleAlgorithm: true,\n    // The number of milliseconds to wait after sending a close frame\n    // for an acknowledgement to come back before giving up and just\n    // closing the socket.\n    closeTimeout: 5000\n  };\n  extend(this.config, config);\n\n  if (this.config.httpServer) {\n    if (!Array.isArray(this.config.httpServer)) {\n      this.config.httpServer = [this.config.httpServer];\n    }\n\n    var upgradeHandler = this._handlers.upgrade;\n    this.config.httpServer.forEach(function (httpServer) {\n      httpServer.on('upgrade', upgradeHandler);\n    });\n  } else {\n    throw new Error('You must specify an httpServer on which to mount the WebSocket server.');\n  }\n};\n\nWebSocketServer.prototype.unmount = function () {\n  var upgradeHandler = this._handlers.upgrade;\n  this.config.httpServer.forEach(function (httpServer) {\n    httpServer.removeListener('upgrade', upgradeHandler);\n  });\n};\n\nWebSocketServer.prototype.closeAllConnections = function () {\n  this.connections.forEach(function (connection) {\n    connection.close();\n  });\n  this.pendingRequests.forEach(function (request) {\n    process.nextTick(function () {\n      request.reject(503); // HTTP 503 Service Unavailable\n    });\n  });\n};\n\nWebSocketServer.prototype.broadcast = function (data) {\n  if (Buffer.isBuffer(data)) {\n    this.broadcastBytes(data);\n  } else if (typeof data.toString === 'function') {\n    this.broadcastUTF(data);\n  }\n};\n\nWebSocketServer.prototype.broadcastUTF = function (utfData) {\n  this.connections.forEach(function (connection) {\n    connection.sendUTF(utfData);\n  });\n};\n\nWebSocketServer.prototype.broadcastBytes = function (binaryData) {\n  this.connections.forEach(function (connection) {\n    connection.sendBytes(binaryData);\n  });\n};\n\nWebSocketServer.prototype.shutDown = function () {\n  this.unmount();\n  this.closeAllConnections();\n};\n\nWebSocketServer.prototype.handleUpgrade = function (request, socket) {\n  var self = this;\n  var wsRequest = new WebSocketRequest(socket, request, this.config);\n\n  try {\n    wsRequest.readHandshake();\n  } catch (e) {\n    wsRequest.reject(e.httpCode ? e.httpCode : 400, e.message, e.headers);\n    debug('Invalid handshake: %s', e.message);\n    this.emit('upgradeError', e);\n    return;\n  }\n\n  this.pendingRequests.push(wsRequest);\n  wsRequest.once('requestAccepted', this._handlers.requestAccepted);\n  wsRequest.once('requestResolved', this._handlers.requestResolved);\n  socket.once('close', function () {\n    self._handlers.requestResolved(wsRequest);\n  });\n\n  if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, 'request') > 0) {\n    this.emit('request', wsRequest);\n  } else if (this.config.autoAcceptConnections) {\n    wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);\n  } else {\n    wsRequest.reject(404, 'No handler is configured to accept the connection.');\n  }\n};\n\nWebSocketServer.prototype.handleRequestAccepted = function (connection) {\n  var self = this;\n  connection.once('close', function (closeReason, description) {\n    self.handleConnectionClose(connection, closeReason, description);\n  });\n  this.connections.push(connection);\n  this.emit('connect', connection);\n};\n\nWebSocketServer.prototype.handleConnectionClose = function (connection, closeReason, description) {\n  var index = this.connections.indexOf(connection);\n\n  if (index !== -1) {\n    this.connections.splice(index, 1);\n  }\n\n  this.emit('close', connection, closeReason, description);\n};\n\nWebSocketServer.prototype.handleRequestResolved = function (request) {\n  var index = this.pendingRequests.indexOf(request);\n\n  if (index !== -1) {\n    this.pendingRequests.splice(index, 1);\n  }\n};\n\nmodule.exports = WebSocketServer;","map":{"version":3,"sources":["/home/thaumy/Desktop/idb5-ui/node_modules/websocket/lib/WebSocketServer.js"],"names":["extend","require","utils","util","debug","EventEmitter","WebSocketRequest","WebSocketServer","config","call","_handlers","upgrade","handleUpgrade","bind","requestAccepted","handleRequestAccepted","requestResolved","handleRequestResolved","connections","pendingRequests","mount","inherits","prototype","httpServer","maxReceivedFrameSize","maxReceivedMessageSize","fragmentOutgoingMessages","fragmentationThreshold","keepalive","keepaliveInterval","dropConnectionOnKeepaliveTimeout","keepaliveGracePeriod","useNativeKeepalive","assembleFragments","autoAcceptConnections","ignoreXForwardedFor","parseCookies","parseExtensions","disableNagleAlgorithm","closeTimeout","Array","isArray","upgradeHandler","forEach","on","Error","unmount","removeListener","closeAllConnections","connection","close","request","process","nextTick","reject","broadcast","data","Buffer","isBuffer","broadcastBytes","toString","broadcastUTF","utfData","sendUTF","binaryData","sendBytes","shutDown","socket","self","wsRequest","readHandshake","e","httpCode","message","headers","emit","push","once","eventEmitterListenerCount","accept","requestedProtocols","origin","closeReason","description","handleConnectionClose","index","indexOf","splice","module","exports"],"mappings":"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","sourcesContent":["/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar extend = require('./utils').extend;\nvar utils = require('./utils');\nvar util = require('util');\nvar debug = require('debug')('websocket:server');\nvar EventEmitter = require('events').EventEmitter;\nvar WebSocketRequest = require('./WebSocketRequest');\n\nvar WebSocketServer = function WebSocketServer(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this._handlers = {\n        upgrade: this.handleUpgrade.bind(this),\n        requestAccepted: this.handleRequestAccepted.bind(this),\n        requestResolved: this.handleRequestResolved.bind(this)\n    };\n    this.connections = [];\n    this.pendingRequests = [];\n    if (config) {\n        this.mount(config);\n    }\n};\n\nutil.inherits(WebSocketServer, EventEmitter);\n\nWebSocketServer.prototype.mount = function(config) {\n    this.config = {\n        // The http server instance to attach to.  Required.\n        httpServer: null,\n\n        // 64KiB max frame size.\n        maxReceivedFrameSize: 0x10000,\n\n        // 1MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x100000,\n\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n\n        // If true, the server will automatically send a ping to all\n        // clients every 'keepaliveInterval' milliseconds.  The timer is\n        // reset on any received data from the client.\n        keepalive: true,\n\n        // The interval to send keepalive pings to connected clients if the\n        // connection is idle.  Any received data will reset the counter.\n        keepaliveInterval: 20000,\n\n        // If true, the server will consider any connection that has not\n        // received any data within the amount of time specified by\n        // 'keepaliveGracePeriod' after a keepalive ping has been sent to\n        // be dead, and will drop the connection.\n        // Ignored if keepalive is false.\n        dropConnectionOnKeepaliveTimeout: true,\n\n        // The amount of time to wait after sending a keepalive ping before\n        // closing the connection if the connected peer does not respond.\n        // Ignored if keepalive is false.\n        keepaliveGracePeriod: 10000,\n\n        // Whether to use native TCP keep-alive instead of WebSockets ping\n        // and pong packets.  Native TCP keep-alive sends smaller packets\n        // on the wire and so uses bandwidth more efficiently.  This may\n        // be more important when talking to mobile devices.\n        // If this value is set to true, then these values will be ignored:\n        //   keepaliveGracePeriod\n        //   dropConnectionOnKeepaliveTimeout\n        useNativeKeepalive: false,\n\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n\n        // If this is true, websocket connections will be accepted\n        // regardless of the path and protocol specified by the client.\n        // The protocol accepted will be the first that was requested\n        // by the client.  Clients from any origin will be accepted.\n        // This should only be used in the simplest of cases.  You should\n        // probably leave this set to 'false' and inspect the request\n        // object to make sure it's acceptable before accepting it.\n        autoAcceptConnections: false,\n\n        // Whether or not the X-Forwarded-For header should be respected.\n        // It's important to set this to 'true' when accepting connections\n        // from untrusted clients, as a malicious client could spoof its\n        // IP address by simply setting this header.  It's meant to be added\n        // by a trusted proxy or other intermediary within your own\n        // infrastructure.\n        // See:  http://en.wikipedia.org/wiki/X-Forwarded-For\n        ignoreXForwardedFor: false,\n\n        // If this is true, 'cookie' headers are parsed and exposed as WebSocketRequest.cookies\n        parseCookies: true,\n\n        // If this is true, 'sec-websocket-extensions' headers are parsed and exposed as WebSocketRequest.requestedExtensions\n        parseExtensions: true,\n\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000\n    };\n    extend(this.config, config);\n\n    if (this.config.httpServer) {\n        if (!Array.isArray(this.config.httpServer)) {\n            this.config.httpServer = [this.config.httpServer];\n        }\n        var upgradeHandler = this._handlers.upgrade;\n        this.config.httpServer.forEach(function(httpServer) {\n            httpServer.on('upgrade', upgradeHandler);\n        });\n    }\n    else {\n        throw new Error('You must specify an httpServer on which to mount the WebSocket server.');\n    }\n};\n\nWebSocketServer.prototype.unmount = function() {\n    var upgradeHandler = this._handlers.upgrade;\n    this.config.httpServer.forEach(function(httpServer) {\n        httpServer.removeListener('upgrade', upgradeHandler);\n    });\n};\n\nWebSocketServer.prototype.closeAllConnections = function() {\n    this.connections.forEach(function(connection) {\n        connection.close();\n    });\n    this.pendingRequests.forEach(function(request) {\n        process.nextTick(function() {\n          request.reject(503); // HTTP 503 Service Unavailable\n        });\n    });\n};\n\nWebSocketServer.prototype.broadcast = function(data) {\n    if (Buffer.isBuffer(data)) {\n        this.broadcastBytes(data);\n    }\n    else if (typeof(data.toString) === 'function') {\n        this.broadcastUTF(data);\n    }\n};\n\nWebSocketServer.prototype.broadcastUTF = function(utfData) {\n    this.connections.forEach(function(connection) {\n        connection.sendUTF(utfData);\n    });\n};\n\nWebSocketServer.prototype.broadcastBytes = function(binaryData) {\n    this.connections.forEach(function(connection) {\n        connection.sendBytes(binaryData);\n    });\n};\n\nWebSocketServer.prototype.shutDown = function() {\n    this.unmount();\n    this.closeAllConnections();\n};\n\nWebSocketServer.prototype.handleUpgrade = function(request, socket) {\n    var self = this;\n    var wsRequest = new WebSocketRequest(socket, request, this.config);\n    try {\n        wsRequest.readHandshake();\n    }\n    catch(e) {\n        wsRequest.reject(\n            e.httpCode ? e.httpCode : 400,\n            e.message,\n            e.headers\n        );\n        debug('Invalid handshake: %s', e.message);\n        this.emit('upgradeError', e);\n        return;\n    }\n\n    this.pendingRequests.push(wsRequest);\n\n    wsRequest.once('requestAccepted', this._handlers.requestAccepted);\n    wsRequest.once('requestResolved', this._handlers.requestResolved);\n    socket.once('close', function () {\n        self._handlers.requestResolved(wsRequest);\n    });\n\n    if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, 'request') > 0) {\n        this.emit('request', wsRequest);\n    }\n    else if (this.config.autoAcceptConnections) {\n        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);\n    }\n    else {\n        wsRequest.reject(404, 'No handler is configured to accept the connection.');\n    }\n};\n\nWebSocketServer.prototype.handleRequestAccepted = function(connection) {\n    var self = this;\n    connection.once('close', function(closeReason, description) {\n        self.handleConnectionClose(connection, closeReason, description);\n    });\n    this.connections.push(connection);\n    this.emit('connect', connection);\n};\n\nWebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {\n    var index = this.connections.indexOf(connection);\n    if (index !== -1) {\n        this.connections.splice(index, 1);\n    }\n    this.emit('close', connection, closeReason, description);\n};\n\nWebSocketServer.prototype.handleRequestResolved = function(request) {\n    var index = this.pendingRequests.indexOf(request);\n    if (index !== -1) { this.pendingRequests.splice(index, 1); }\n};\n\nmodule.exports = WebSocketServer;\n"]},"metadata":{},"sourceType":"script"}