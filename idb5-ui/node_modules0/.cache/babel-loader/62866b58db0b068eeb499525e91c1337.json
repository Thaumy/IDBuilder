{"ast":null,"code":"/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */\n'use strict';\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst {\n  randomFillSync\n} = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\n\nconst {\n  EMPTY_BUFFER\n} = require('./constants');\n\nconst {\n  isValidStatusCode\n} = require('./validation');\n\nconst {\n  mask: applyMask,\n  toBuffer\n} = require('./buffer-util');\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\n/**\n * HyBi Sender implementation.\n */\n\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n    this._firstFragment = true;\n    this._compress = false;\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n\n\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        randomFillSync(mask, 0, 4);\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n\n      if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(Sender.frame(data, {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1: false\n      }), cb);\n    }\n  }\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error('The socket was closed while data was being compressed');\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n\n\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n\n\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n\n    this._queue.push(params);\n  }\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n\n      this._socket.write(list[0]);\n\n      this._socket.write(list[1], cb);\n\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n\n}\n\nmodule.exports = Sender;","map":{"version":3,"sources":["/home/thaumy/Desktop/idb5-ui/node_modules/ws/lib/sender.js"],"names":["net","require","tls","randomFillSync","PerMessageDeflate","EMPTY_BUFFER","isValidStatusCode","mask","applyMask","toBuffer","kByteLength","Symbol","maskBuffer","Buffer","alloc","Sender","constructor","socket","extensions","generateMask","_extensions","_generateMask","_maskBuffer","_socket","_firstFragment","_compress","_bufferedBytes","_deflating","_queue","frame","data","options","merge","offset","skipMasking","dataLength","undefined","from","length","readOnly","payloadLength","target","allocUnsafe","fin","opcode","rsv1","writeUInt16BE","writeUIntBE","close","code","cb","buf","TypeError","byteLength","RangeError","write","set","enqueue","dispatch","sendFrame","ping","pong","send","perMessageDeflate","extensionName","binary","compress","params","_isServer","_threshold","opts","_","destroyed","err","Error","i","callback","dequeue","shift","Reflect","apply","slice","push","list","cork","uncork","module","exports"],"mappings":"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","sourcesContent":["/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */\n\n'use strict';\n\nconst net = require('net');\nconst tls = require('tls');\nconst { randomFillSync } = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst { EMPTY_BUFFER } = require('./constants');\nconst { isValidStatusCode } = require('./validation');\nconst { mask: applyMask, toBuffer } = require('./buffer-util');\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        randomFillSync(mask, 0, 4);\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if (\n        (!options.mask || skipMasking) &&\n        options[kByteLength] !== undefined\n      ) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(data, {\n          [kByteLength]: byteLength,\n          fin: options.fin,\n          generateMask: this._generateMask,\n          mask: options.mask,\n          maskBuffer: this._maskBuffer,\n          opcode,\n          readOnly,\n          rsv1: false\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n"]},"metadata":{},"sourceType":"script"}