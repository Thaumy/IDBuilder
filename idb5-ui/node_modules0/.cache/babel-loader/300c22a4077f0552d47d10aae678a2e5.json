{"ast":null,"code":"import { withDirectives as _withDirectives, mergeProps as _mergeProps, resolveDirective as _resolveDirective, vModelText as _vModelText, createVNode as _createVNode, Fragment as _Fragment } from \"vue\"; // Styles\n\nimport \"./VTextarea.css\"; // Components\n\nimport { filterFieldProps, makeVFieldProps } from \"../VField/VField.mjs\";\nimport { VCounter } from \"../VCounter/index.mjs\";\nimport { VField } from \"../VField/index.mjs\"; // Composables\n\nimport { useProxiedModel } from \"../../composables/proxiedModel.mjs\"; // Directives\n\nimport Intersect from \"../../directives/intersect/index.mjs\"; // Utilities\n\nimport { computed, nextTick, onBeforeUnmount, onMounted, ref, watch } from 'vue';\nimport { convertToUnit, defineComponent, useRender } from \"../../util/index.mjs\"; // Types\n\nimport { filterInputAttrs } from \"../VInput/VInput.mjs\";\nexport const VTextarea = defineComponent({\n  name: 'VTextarea',\n  directives: {\n    Intersect\n  },\n  inheritAttrs: false,\n  props: {\n    autoGrow: Boolean,\n    autofocus: Boolean,\n    counter: [Boolean, Number, String],\n    counterValue: Function,\n    prefix: String,\n    placeholder: String,\n    persistentPlaceholder: Boolean,\n    persistentCounter: Boolean,\n    noResize: Boolean,\n    rows: {\n      type: [Number, String],\n      default: 5,\n      validator: v => !isNaN(parseFloat(v))\n    },\n    maxRows: {\n      type: [Number, String],\n      validator: v => !isNaN(parseFloat(v))\n    },\n    suffix: String,\n    ...makeVFieldProps()\n  },\n  emits: {\n    'update:modelValue': val => true\n  },\n\n  setup(props, _ref) {\n    let {\n      attrs,\n      slots\n    } = _ref;\n    const model = useProxiedModel(props, 'modelValue');\n    const controlHeight = ref('auto');\n    const internalDirty = ref(false);\n    const isDirty = computed(() => {\n      return internalDirty.value || !!model.value;\n    });\n    const counterValue = computed(() => {\n      return typeof props.counterValue === 'function' ? props.counterValue(model.value) : (model.value || '').toString().length;\n    });\n    const max = computed(() => {\n      if (attrs.maxlength) return attrs.maxlength;\n      if (!props.counter || typeof props.counter !== 'number' && typeof props.counter !== 'string') return undefined;\n      return props.counter;\n    });\n\n    function onIntersect(isIntersecting, entries) {\n      var _entries$0$target, _entries$0$target$foc;\n\n      if (!props.autofocus || !isIntersecting) return;\n      (_entries$0$target = entries[0].target) == null ? void 0 : (_entries$0$target$foc = _entries$0$target.focus) == null ? void 0 : _entries$0$target$foc.call(_entries$0$target);\n    }\n\n    const fieldRef = ref();\n\n    function focus() {\n      var _fieldRef$value, _fieldRef$value$input;\n\n      (_fieldRef$value = fieldRef.value) == null ? void 0 : (_fieldRef$value$input = _fieldRef$value.inputRef) == null ? void 0 : _fieldRef$value$input.focus();\n    }\n\n    function blur() {\n      var _fieldRef$value2, _fieldRef$value2$inpu;\n\n      (_fieldRef$value2 = fieldRef.value) == null ? void 0 : (_fieldRef$value2$inpu = _fieldRef$value2.inputRef) == null ? void 0 : _fieldRef$value2$inpu.blur();\n    }\n\n    const sizerRef = ref();\n\n    function calculateInputHeight() {\n      if (!props.autoGrow) return;\n      nextTick(() => {\n        if (!sizerRef.value) return;\n        const style = getComputedStyle(sizerRef.value);\n        const padding = parseFloat(style.getPropertyValue('--v-field-padding-top')) + parseFloat(style.getPropertyValue('--v-field-padding-bottom'));\n        const height = sizerRef.value.scrollHeight;\n        const lineHeight = parseFloat(style.lineHeight);\n        const minHeight = parseFloat(props.rows) * lineHeight + padding;\n        const maxHeight = parseFloat(props.maxRows) * lineHeight + padding || Infinity;\n        controlHeight.value = convertToUnit(Math.min(maxHeight, Math.max(minHeight, height != null ? height : 0)));\n      });\n    }\n\n    onMounted(calculateInputHeight);\n    watch(model, calculateInputHeight);\n    watch(() => props.rows, calculateInputHeight);\n    watch(() => props.maxRows, calculateInputHeight);\n    let observer;\n    watch(sizerRef, val => {\n      if (val) {\n        observer = new ResizeObserver(calculateInputHeight);\n        observer.observe(sizerRef.value);\n      } else {\n        var _observer;\n\n        (_observer = observer) == null ? void 0 : _observer.disconnect();\n      }\n    });\n    onBeforeUnmount(() => {\n      var _observer2;\n\n      (_observer2 = observer) == null ? void 0 : _observer2.disconnect();\n    });\n    useRender(() => {\n      const hasCounter = !!(slots.counter || props.counter || props.counterValue);\n      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);\n      const [fieldProps, _] = filterFieldProps(props);\n      return _createVNode(VField, _mergeProps({\n        \"ref\": fieldRef,\n        \"class\": ['v-textarea', {\n          'v-textarea--prefixed': props.prefix,\n          'v-textarea--suffixed': props.suffix,\n          'v-textarea--auto-grow': props.autoGrow,\n          'v-textarea--no-resize': props.noResize || props.autoGrow\n        }, attrs.class],\n        \"style\": {\n          '--v-input-control-height': controlHeight.value\n        },\n        \"active\": isDirty.value,\n        \"onUpdate:active\": val => internalDirty.value = val,\n        \"onClick:control\": focus,\n        \"onClick:clear\": e => {\n          e.stopPropagation();\n          model.value = '';\n        },\n        \"role\": \"textbox\"\n      }, rootAttrs, fieldProps), { ...slots,\n        default: _ref2 => {\n          let {\n            isActive,\n            isDisabled,\n            isReadonly,\n            inputRef,\n            props: {\n              class: fieldClass,\n              ...slotProps\n            }\n          } = _ref2;\n          const showPlaceholder = isActive || props.persistentPlaceholder;\n          return _createVNode(_Fragment, null, [props.prefix && _createVNode(\"span\", {\n            \"class\": \"v-textarea__prefix\",\n            \"style\": {\n              opacity: showPlaceholder ? undefined : '0'\n            }\n          }, [props.prefix], 4), _withDirectives(_createVNode(\"textarea\", _mergeProps({\n            \"class\": fieldClass,\n            \"style\": {\n              opacity: showPlaceholder ? undefined : '0'\n            },\n            \"onUpdate:modelValue\": $event => model.value = $event,\n            \"ref\": inputRef,\n            \"autofocus\": props.autofocus,\n            \"readonly\": isReadonly.value,\n            \"disabled\": isDisabled.value,\n            \"placeholder\": props.placeholder,\n            \"rows\": props.rows\n          }, slotProps, inputAttrs), null, 16, [\"onUpdate:modelValue\", \"autofocus\", \"readonly\", \"disabled\", \"placeholder\", \"rows\"]), [[_vModelText, model.value], [_resolveDirective(\"intersect\"), {\n            handler: onIntersect\n          }, null, {\n            once: true\n          }]]), props.autoGrow && _withDirectives(_createVNode(\"textarea\", {\n            \"class\": [fieldClass, 'v-textarea__sizer'],\n            \"onUpdate:modelValue\": $event => model.value = $event,\n            \"ref\": sizerRef,\n            \"readonly\": true,\n            \"aria-hidden\": \"true\"\n          }, null, 10, [\"onUpdate:modelValue\", \"readonly\"]), [[_vModelText, model.value]]), props.suffix && _createVNode(\"span\", {\n            \"class\": \"v-textarea__suffix\",\n            \"style\": {\n              opacity: showPlaceholder ? undefined : '0'\n            }\n          }, [props.suffix], 4)]);\n        },\n        details: hasCounter ? _ref3 => {\n          let {\n            isFocused\n          } = _ref3;\n          return _createVNode(_Fragment, null, [_createVNode(\"span\", null, null), _createVNode(VCounter, {\n            \"active\": props.persistentCounter || isFocused,\n            \"value\": counterValue.value,\n            \"max\": max.value\n          }, slots.counter, 8, [\"active\", \"value\", \"max\"])]);\n        } : undefined\n      }, 16, [\"class\", \"style\", \"active\", \"onUpdate:active\", \"onClick:control\", \"onClick:clear\"]);\n    });\n    return {\n      fieldRef,\n      focus,\n      blur\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["filterFieldProps","makeVFieldProps","VCounter","VField","useProxiedModel","Intersect","computed","nextTick","onBeforeUnmount","onMounted","ref","watch","convertToUnit","defineComponent","useRender","filterInputAttrs","VTextarea","name","directives","inheritAttrs","props","autoGrow","Boolean","autofocus","counter","Number","String","counterValue","Function","prefix","placeholder","persistentPlaceholder","persistentCounter","noResize","rows","type","default","validator","v","isNaN","parseFloat","maxRows","suffix","emits","val","setup","attrs","slots","_ref","model","controlHeight","internalDirty","isDirty","value","toString","length","max","maxlength","undefined","onIntersect","isIntersecting","entries","target","focus","fieldRef","inputRef","blur","sizerRef","calculateInputHeight","style","getComputedStyle","padding","getPropertyValue","height","scrollHeight","lineHeight","minHeight","maxHeight","Infinity","Math","min","observer","ResizeObserver","observe","disconnect","hasCounter","rootAttrs","inputAttrs","fieldProps","_","class","e","stopPropagation","_ref2","isActive","isDisabled","isReadonly","fieldClass","slotProps","showPlaceholder","opacity","$event","handler","once","details","_ref3","isFocused"],"sources":["../../../src/components/VTextarea/VTextarea.tsx"],"sourcesContent":["// Styles\nimport './VTextarea.sass'\n\n// Components\nimport { filterFieldProps, makeVFieldProps } from '@/components/VField/VField'\nimport { VCounter } from '@/components/VCounter'\nimport { VField } from '@/components/VField'\n\n// Composables\nimport { useProxiedModel } from '@/composables/proxiedModel'\n\n// Directives\nimport Intersect from '@/directives/intersect'\n\n// Utilities\nimport { computed, nextTick, onBeforeUnmount, onMounted, ref, watch } from 'vue'\nimport { convertToUnit, defineComponent, useRender } from '@/util'\n\n// Types\nimport type { PropType } from 'vue'\nimport { filterInputAttrs } from '@/components/VInput/VInput'\n\nexport const VTextarea = defineComponent({\n  name: 'VTextarea',\n\n  directives: { Intersect },\n\n  inheritAttrs: false,\n\n  props: {\n    autoGrow: Boolean,\n    autofocus: Boolean,\n    counter: [Boolean, Number, String] as PropType<true | number | string>,\n    counterValue: Function as PropType<(value: any) => number>,\n    prefix: String,\n    placeholder: String,\n    persistentPlaceholder: Boolean,\n    persistentCounter: Boolean,\n    noResize: Boolean,\n    rows: {\n      type: [Number, String],\n      default: 5,\n      validator: (v: any) => !isNaN(parseFloat(v)),\n    },\n    maxRows: {\n      type: [Number, String],\n      validator: (v: any) => !isNaN(parseFloat(v)),\n    },\n    suffix: String,\n\n    ...makeVFieldProps(),\n  },\n\n  emits: {\n    'update:modelValue': (val: string) => true,\n  },\n\n  setup (props, { attrs, slots }) {\n    const model = useProxiedModel(props, 'modelValue')\n\n    const controlHeight = ref('auto')\n    const internalDirty = ref(false)\n    const isDirty = computed(() => {\n      return internalDirty.value || !!model.value\n    })\n\n    const counterValue = computed(() => {\n      return typeof props.counterValue === 'function'\n        ? props.counterValue(model.value)\n        : (model.value || '').toString().length\n    })\n    const max = computed(() => {\n      if (attrs.maxlength) return attrs.maxlength as undefined\n\n      if (\n        !props.counter ||\n        (typeof props.counter !== 'number' &&\n        typeof props.counter !== 'string')\n      ) return undefined\n\n      return props.counter\n    })\n\n    function onIntersect (\n      isIntersecting: boolean,\n      entries: IntersectionObserverEntry[]\n    ) {\n      if (!props.autofocus || !isIntersecting) return\n\n      (entries[0].target as HTMLInputElement)?.focus?.()\n    }\n\n    const fieldRef = ref<VField>()\n    function focus () {\n      fieldRef.value?.inputRef?.focus()\n    }\n    function blur () {\n      fieldRef.value?.inputRef?.blur()\n    }\n\n    const sizerRef = ref<HTMLTextAreaElement>()\n    function calculateInputHeight () {\n      if (!props.autoGrow) return\n\n      nextTick(() => {\n        if (!sizerRef.value) return\n\n        const style = getComputedStyle(sizerRef.value)\n\n        const padding = parseFloat(style.getPropertyValue('--v-field-padding-top')) +\n        parseFloat(style.getPropertyValue('--v-field-padding-bottom'))\n\n        const height = sizerRef.value.scrollHeight\n        const lineHeight = parseFloat(style.lineHeight)\n        const minHeight = parseFloat(props.rows) * lineHeight + padding\n        const maxHeight = parseFloat(props.maxRows!) * lineHeight + padding || Infinity\n\n        controlHeight.value = convertToUnit(Math.min(maxHeight, Math.max(minHeight, height ?? 0)))\n      })\n    }\n\n    onMounted(calculateInputHeight)\n    watch(model, calculateInputHeight)\n    watch(() => props.rows, calculateInputHeight)\n    watch(() => props.maxRows, calculateInputHeight)\n\n    let observer: ResizeObserver | undefined\n    watch(sizerRef, val => {\n      if (val) {\n        observer = new ResizeObserver(calculateInputHeight)\n        observer.observe(sizerRef.value!)\n      } else {\n        observer?.disconnect()\n      }\n    })\n    onBeforeUnmount(() => {\n      observer?.disconnect()\n    })\n\n    useRender(() => {\n      const hasCounter = !!(slots.counter || props.counter || props.counterValue)\n      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs)\n      const [fieldProps, _] = filterFieldProps(props)\n\n      return (\n        <VField\n          ref={ fieldRef }\n          class={[\n            'v-textarea',\n            {\n              'v-textarea--prefixed': props.prefix,\n              'v-textarea--suffixed': props.suffix,\n              'v-textarea--auto-grow': props.autoGrow,\n              'v-textarea--no-resize': props.noResize || props.autoGrow,\n            },\n            attrs.class,\n          ]}\n          style={{\n            '--v-input-control-height': controlHeight.value,\n          }}\n          active={ isDirty.value }\n          onUpdate:active={ val => internalDirty.value = val }\n          onClick:control={ focus }\n          onClick:clear={ e => {\n            e.stopPropagation()\n\n            model.value = ''\n          }}\n          role=\"textbox\"\n          { ...rootAttrs }\n          { ...fieldProps }\n          v-slots={{\n            ...slots,\n            default: ({\n              isActive,\n              isDisabled,\n              isReadonly,\n              inputRef,\n              props: { class: fieldClass, ...slotProps },\n            }) => {\n              const showPlaceholder = isActive || props.persistentPlaceholder\n              return (\n                <>\n                  { props.prefix && (\n                    <span class=\"v-textarea__prefix\" style={{ opacity: showPlaceholder ? undefined : '0' }}>\n                      { props.prefix }\n                    </span>\n                  ) }\n\n                  <textarea\n                    class={ fieldClass }\n                    style={{ opacity: showPlaceholder ? undefined : '0' }} // can't this just be a class?\n                    v-model={ model.value }\n                    v-intersect={[{\n                      handler: onIntersect,\n                    }, null, ['once']]}\n                    ref={ inputRef }\n                    autofocus={ props.autofocus }\n                    readonly={ isReadonly.value }\n                    disabled={ isDisabled.value }\n                    placeholder={ props.placeholder }\n                    rows={ props.rows }\n                    { ...slotProps }\n                    { ...inputAttrs }\n                  />\n\n                  { props.autoGrow && (\n                    <textarea\n                      class={[\n                        fieldClass,\n                        'v-textarea__sizer',\n                      ]}\n                      v-model={ model.value }\n                      ref={ sizerRef }\n                      readonly\n                      aria-hidden=\"true\"\n                    />\n                  )}\n\n                  { props.suffix && (\n                    <span class=\"v-textarea__suffix\" style={{ opacity: showPlaceholder ? undefined : '0' }}>\n                      { props.suffix }\n                    </span>\n                  ) }\n                </>\n              )\n            },\n            details: hasCounter ? ({ isFocused }) => (\n              <>\n                <span />\n\n                <VCounter\n                  active={ props.persistentCounter || isFocused }\n                  value={ counterValue.value }\n                  max={ max.value }\n                  v-slots={ slots.counter }\n                />\n              </>\n            ) : undefined,\n          }}\n        />\n      )\n    })\n\n    return {\n      fieldRef,\n      focus,\n      blur,\n    }\n  },\n})\n\nexport type VTextarea = InstanceType<typeof VTextarea>\n"]},"metadata":{},"sourceType":"module"}