{"ast":null,"code":"'use strict';\n\nconst {\n  kForOnEventAttribute,\n  kListener\n} = require('./constants');\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n/**\n * Class representing an event.\n */\n\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n  /**\n   * @type {*}\n   */\n\n\n  get target() {\n    return this[kTarget];\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get type() {\n    return this[kType];\n  }\n\n}\n\nObject.defineProperty(Event.prototype, 'target', {\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, 'type', {\n  enumerable: true\n});\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\n\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n  /**\n   * @type {Number}\n   */\n\n\n  get code() {\n    return this[kCode];\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get reason() {\n    return this[kReason];\n  }\n  /**\n   * @type {Boolean}\n   */\n\n\n  get wasClean() {\n    return this[kWasClean];\n  }\n\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, 'reason', {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, 'wasClean', {\n  enumerable: true\n});\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\n\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n  /**\n   * @type {*}\n   */\n\n\n  get error() {\n    return this[kError];\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get message() {\n    return this[kMessage];\n  }\n\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', {\n  enumerable: true\n});\nObject.defineProperty(ErrorEvent.prototype, 'message', {\n  enumerable: true\n});\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\n\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n  /**\n   * @type {*}\n   */\n\n\n  get data() {\n    return this[kData];\n  }\n\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', {\n  enumerable: true\n});\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\n\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, listener, options = {}) {\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = listener;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {Function} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n\n};\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};","map":{"version":3,"sources":["/home/thaumy/Desktop/idb5-ui/node_modules/ws/lib/event-target.js"],"names":["kForOnEventAttribute","kListener","require","kCode","Symbol","kData","kError","kMessage","kReason","kTarget","kType","kWasClean","Event","constructor","type","target","Object","defineProperty","prototype","enumerable","CloseEvent","options","code","undefined","reason","wasClean","ErrorEvent","error","message","MessageEvent","data","EventTarget","addEventListener","listener","wrapper","onMessage","isBinary","event","toString","call","onClose","_closeFrameReceived","_closeFrameSent","onError","onOpen","once","on","removeEventListener","handler","listeners","removeListener","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { kForOnEventAttribute, kListener } = require('./constants');\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, listener, options = {}) {\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = listener;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {Function} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n"]},"metadata":{},"sourceType":"script"}