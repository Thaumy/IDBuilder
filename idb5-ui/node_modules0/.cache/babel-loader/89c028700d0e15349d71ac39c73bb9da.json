{"ast":null,"code":"// Utils\nimport { defineComponent as _defineComponent, getCurrentInstance, shallowReactive, toRaw, watchEffect } from 'vue';\nimport { consoleWarn } from \"./console.mjs\";\nimport { toKebabCase } from \"./helpers.mjs\";\nimport { useDefaults } from \"../composables/defaults.mjs\"; // Types\n\nfunction propIsDefined(vnode, prop) {\n  var _vnode$props, _vnode$props2;\n\n  return ((_vnode$props = vnode.props) == null ? void 0 : _vnode$props.hasOwnProperty(prop)) || ((_vnode$props2 = vnode.props) == null ? void 0 : _vnode$props2.hasOwnProperty(toKebabCase(prop)));\n}\n\nexport const defineComponent = function defineComponent(options) {\n  var _options$_setup;\n\n  options._setup = (_options$_setup = options._setup) != null ? _options$_setup : options.setup;\n\n  if (!options.name) {\n    consoleWarn('The component is missing an explicit name, unable to generate default prop value');\n    return options;\n  }\n\n  if (options._setup) {\n    options.setup = function setup(props, ctx) {\n      const vm = getCurrentInstance();\n      const defaults = useDefaults();\n\n      const _props = shallowReactive({ ...toRaw(props)\n      });\n\n      watchEffect(() => {\n        const globalDefaults = defaults.value.global;\n        const componentDefaults = defaults.value[options.name];\n\n        for (const prop of Object.keys(props)) {\n          let newVal;\n\n          if (propIsDefined(vm.vnode, prop)) {\n            newVal = props[prop];\n          } else {\n            var _ref, _componentDefaults$pr;\n\n            newVal = (_ref = (_componentDefaults$pr = componentDefaults == null ? void 0 : componentDefaults[prop]) != null ? _componentDefaults$pr : globalDefaults == null ? void 0 : globalDefaults[prop]) != null ? _ref : props[prop];\n          }\n\n          if (_props[prop] !== newVal) {\n            _props[prop] = newVal;\n          }\n        }\n      });\n      return options._setup(_props, ctx);\n    };\n  }\n\n  return options;\n};\nexport function genericComponent() {\n  let exposeDefaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  return options => (exposeDefaults ? defineComponent : _defineComponent)(options);\n}","map":{"version":3,"mappings":"AAAA;AACA,SACEA,eAAe,IAAIC,gBADrB,EAEEC,kBAFF,EAGEC,eAHF,EAIEC,KAJF,EAKEC,WALF,QAMO,KANP;SAOSC,mB;SACAC,mB;SACAC,mB,+BAET;;AAaA,SAASC,aAAT,CAAwBC,KAAxB,EAAsCC,IAAtC,EAAoD;AAAA;;AAClD,SAAO,sBAAK,CAACC,KAAN,kCAAaC,cAAb,CAA4BF,IAA5B,wBACPD,KAAK,CAACE,KADC,qBACPE,cAAaD,cAAb,CAA4BN,WAAW,CAACI,IAAD,CAAvC,CADO,CAAP;AAED;;AAED,OAAO,MAAMX,eAAe,GAAI,SAASA,eAAT,CAA0Be,OAA1B,EAAqD;AAAA;;AACnFA,SAAO,CAACC,MAARD,sBAAiBA,OAAO,CAACC,MAAzB,8BAAmCD,OAAO,CAACE,KAA3CF;;AAEA,MAAI,CAACA,OAAO,CAACG,IAAb,EAAmB;AACjBZ,eAAW,CAAC,kFAAD,CAAXA;AAEA,WAAOS,OAAP;AACD;;AAED,MAAIA,OAAO,CAACC,MAAZ,EAAoB;AAClBD,WAAO,CAACE,KAARF,GAAgB,SAASE,KAAT,CAAgBL,KAAhB,EAAwCO,GAAxC,EAA6C;AAC3D,YAAMC,EAAE,GAAGlB,kBAAkB,EAA7B;AACA,YAAMmB,QAAQ,GAAGb,WAAW,EAA5B;;AAEA,YAAMc,MAAM,GAAGnB,eAAe,CAAC,EAAE,GAAGC,KAAK,CAACQ,KAAD;AAAV,OAAD,CAA9B;;AACAP,iBAAW,CAAC,MAAM;AAChB,cAAMkB,cAAc,GAAGF,QAAQ,CAACG,KAATH,CAAeI,MAAtC;AACA,cAAMC,iBAAiB,GAAGL,QAAQ,CAACG,KAATH,CAAeN,OAAO,CAACG,IAAvBG,CAA1B;;AAEA,aAAK,MAAMV,IAAX,IAAmBgB,MAAM,CAACC,IAAPD,CAAYf,KAAZe,CAAnB,EAAuC;AACrC,cAAIE,MAAJ;;AACA,cAAIpB,aAAa,CAACW,EAAE,CAACV,KAAJ,EAAWC,IAAX,CAAjB,EAAmC;AACjCkB,kBAAM,GAAGjB,KAAK,CAACD,IAAD,CAAdkB;AADF,iBAEO;AAAA;;AACLA,kBAAM,oCAAGH,iBAAH,QAAGA,GAAH,MAAGA,oBAAiB,CAAGf,IAAH,CAApB,oCAAgCY,cAAhC,QAAgCA,GAAhC,MAAgCA,iBAAc,CAAGZ,IAAH,CAA9C,mBAA0DC,KAAK,CAACD,IAAD,CAArEkB;AACD;;AACD,cAAIP,MAAM,CAACX,IAAD,CAANW,KAAiBO,MAArB,EAA6B;AAC3BP,kBAAM,CAACX,IAAD,CAANW,GAAeO,MAAfP;AACD;AACF;AAdQ,QAAXjB;AAiBA,aAAOU,OAAO,CAACC,MAARD,CAAeO,MAAfP,EAAuBI,GAAvBJ,CAAP;AAtBF;AAwBD;;AAED,SAAOA,OAAP;AApCK;AAmDP,OAAO,SAASe,gBAAT,GA4B4G;AAAA,MA1B9GC,cA0B8G,uEA1B7F,IA0B6F;AACjH,SAAOhB,OAAO,IAAI,CAACgB,cAAc,GAAG/B,eAAH,GAAqBC,gBAApC,EAAsDc,OAAtD,CAAlB;AACD","names":["defineComponent","_defineComponent","getCurrentInstance","shallowReactive","toRaw","watchEffect","consoleWarn","toKebabCase","useDefaults","propIsDefined","vnode","prop","props","hasOwnProperty","_vnode$props2","options","_setup","setup","name","ctx","vm","defaults","_props","globalDefaults","value","global","componentDefaults","Object","keys","newVal","genericComponent","exposeDefaults"],"sources":["../../src/util/defineComponent.tsx"],"sourcesContent":["// Utils\nimport {\n  defineComponent as _defineComponent,\n  getCurrentInstance,\n  shallowReactive,\n  toRaw,\n  watchEffect,\n} from 'vue'\nimport { consoleWarn } from '@/util/console'\nimport { toKebabCase } from '@/util/helpers'\nimport { useDefaults } from '@/composables/defaults'\n\n// Types\nimport type {\n  ComponentOptions,\n  ComponentOptionsMixin,\n  ComponentOptionsWithObjectProps,\n  ComponentPropsOptions,\n  ComputedOptions,\n  DefineComponent,\n  EmitsOptions,\n  MethodOptions,\n  VNode,\n} from 'vue'\n\nfunction propIsDefined (vnode: VNode, prop: string) {\n  return vnode.props?.hasOwnProperty(prop) ||\n  vnode.props?.hasOwnProperty(toKebabCase(prop))\n}\n\nexport const defineComponent = (function defineComponent (options: ComponentOptions) {\n  options._setup = options._setup ?? options.setup\n\n  if (!options.name) {\n    consoleWarn('The component is missing an explicit name, unable to generate default prop value')\n\n    return options\n  }\n\n  if (options._setup) {\n    options.setup = function setup (props: Dictionary<any>, ctx) {\n      const vm = getCurrentInstance()!\n      const defaults = useDefaults()\n\n      const _props = shallowReactive({ ...toRaw(props) })\n      watchEffect(() => {\n        const globalDefaults = defaults.value.global\n        const componentDefaults = defaults.value[options.name!]\n\n        for (const prop of Object.keys(props)) {\n          let newVal\n          if (propIsDefined(vm.vnode, prop)) {\n            newVal = props[prop]\n          } else {\n            newVal = componentDefaults?.[prop] ?? globalDefaults?.[prop] ?? props[prop]\n          }\n          if (_props[prop] !== newVal) {\n            _props[prop] = newVal\n          }\n        }\n      })\n\n      return options._setup(_props, ctx)\n    }\n  }\n\n  return options\n}) as unknown as typeof _defineComponent\n\ntype ToListeners<T extends string | number | symbol> = { [K in T]: K extends `on${infer U}` ? Uncapitalize<U> : K }[T]\ntype SlotsToProps<T extends Record<string, Slot>> = {\n  'v-slots': new () => { [K in keyof T]?: T[K] | false }\n}/* & { // TODO: individual slots are never converted from the constructor type\n  [K in keyof T as `v-slot:${K & string}`]?: new () => (T[K] | false)\n} */\n\ntype Slot<T extends any[] = any[]> = (...args: T) => VNode | VNode[] | undefined\nexport type MakeSlots<T extends Record<string, any[]>> = {\n  [K in keyof T]?: Slot<T[K]>\n}\n\nexport function genericComponent<T extends (new () => {\n  $slots?: Record<string, Slot>\n})> (exposeDefaults = true): <\n  PropsOptions extends Readonly<ComponentPropsOptions>,\n  RawBindings,\n  D,\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = Record<string, any>,\n  EE extends string = string,\n  I = InstanceType<T>,\n  Base = DefineComponent<\n    (I extends Record<'$props', any> ? Omit<PropsOptions, keyof I['$props']> : PropsOptions) & (\n      I extends Record<'$slots', any>\n        ? SlotsToProps<I['$slots']>\n        : {}\n    ),\n    RawBindings,\n    D,\n    C,\n    M,\n    Mixin,\n    Extends,\n    E extends any[] ? E : I extends Record<'$props', any> ? Omit<E, ToListeners<keyof I['$props']>> : E,\n    EE\n  >\n>(options: ComponentOptionsWithObjectProps<PropsOptions, RawBindings, D, C, M, Mixin, Extends, E, EE>) => Base & T {\n  return options => (exposeDefaults ? defineComponent : _defineComponent)(options) as any\n}\n"]},"metadata":{},"sourceType":"module"}