{"ast":null,"code":"import { useProxiedModel } from \"../proxiedModel.mjs\";\nimport { getUid, propsFactory } from \"../../util/index.mjs\";\nimport { computed, inject, onBeforeUnmount, provide, ref } from 'vue';\nimport { multipleOpenStrategy, singleOpenStrategy } from \"./openStrategies.mjs\";\nimport { classicSelectStrategy, independentSelectStrategy, leafSelectStrategy } from \"./selectStrategies.mjs\";\nimport { classicActiveStrategy } from \"./activeStrategies.mjs\"; // Types\n\nconst VNestedSymbol = Symbol.for('vuetify:nested');\nconst emptyNested = {\n  id: ref(null),\n  root: {\n    register: () => null,\n    unregister: () => null,\n    parents: ref(new Map()),\n    children: ref(new Map()),\n    open: () => null,\n    select: () => null,\n    opened: ref(new Set()),\n    selected: ref(new Map()),\n    active: ref(new Set()),\n    activate: () => null,\n    selectedValues: ref([])\n  }\n};\nexport const makeNestedProps = propsFactory({\n  selectStrategy: [String, Function],\n  openStrategy: [String, Function],\n  activeStrategy: [String, Function],\n  opened: Array,\n  selected: Array,\n  active: Array\n}, 'nested');\nexport const useNested = props => {\n  let isUnmounted = false;\n  const children = ref(new Map());\n  const parents = ref(new Map());\n  const opened = useProxiedModel(props, 'opened', props.opened, v => new Set(v), v => [...v.values()]);\n  const active = useProxiedModel(props, 'active', props.active, v => new Set(v), v => [...v.values()]);\n  const activeStrategy = computed(() => {\n    if (typeof props.activeStrategy === 'object') return props.activeStrategy;\n\n    switch (props.activeStrategy) {\n      case 'single':\n        return classicActiveStrategy(true);\n\n      case 'multiple':\n      default:\n        return classicActiveStrategy();\n    }\n  });\n  const selectStrategy = computed(() => {\n    if (typeof props.selectStrategy === 'object') return props.selectStrategy;\n\n    switch (props.selectStrategy) {\n      case 'single-leaf':\n        return leafSelectStrategy(true);\n\n      case 'leaf':\n        return leafSelectStrategy();\n\n      case 'independent':\n        return independentSelectStrategy;\n\n      case 'classic':\n      default:\n        return classicSelectStrategy;\n    }\n  });\n  const openStrategy = computed(() => {\n    if (typeof props.openStrategy === 'function') return props.openStrategy;\n\n    switch (props.openStrategy) {\n      case 'single':\n        return singleOpenStrategy;\n\n      case 'multiple':\n      default:\n        return multipleOpenStrategy;\n    }\n  });\n  const selected = useProxiedModel(props, 'selected', props.selected, v => selectStrategy.value.in(v, children.value, parents.value), v => selectStrategy.value.out(v, children.value, parents.value));\n  onBeforeUnmount(() => {\n    isUnmounted = true;\n  });\n  const nested = {\n    id: ref(null),\n    root: {\n      opened,\n      selected,\n      active,\n      selectedValues: computed(() => {\n        const arr = [];\n\n        for (const [key, value] of selected.value.entries()) {\n          if (value === 'on') arr.push(key);\n        }\n\n        return arr;\n      }),\n      register: (id, parentId, isGroup) => {\n        parentId && parents.value.set(id, parentId);\n        isGroup && children.value.set(id, []);\n\n        if (parentId != null) {\n          children.value.set(parentId, [...(children.value.get(parentId) || []), id]);\n        }\n      },\n      unregister: id => {\n        if (isUnmounted) return;\n        children.value.delete(id);\n        const parent = parents.value.get(id);\n\n        if (parent) {\n          var _children$value$get;\n\n          const list = (_children$value$get = children.value.get(parent)) != null ? _children$value$get : [];\n          children.value.set(parent, list.filter(child => child !== id));\n        }\n\n        parents.value.delete(id);\n        opened.value.delete(id);\n        active.value.delete(id);\n        selected.value.delete(id);\n      },\n      open: (id, value, event) => {\n        const newOpened = openStrategy.value({\n          id,\n          value,\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event\n        });\n        newOpened && (opened.value = newOpened);\n      },\n      select: (id, value, event) => {\n        const newSelected = selectStrategy.value.select({\n          id,\n          value,\n          selected: new Map(selected.value),\n          children: children.value,\n          parents: parents.value,\n          event\n        });\n        newSelected && (selected.value = newSelected);\n      },\n      activate: (id, value, event) => {\n        const newActive = activeStrategy.value({\n          id,\n          value,\n          active: new Set(active.value),\n          children: children.value,\n          parents: parents.value,\n          event\n        });\n        newActive && (active.value = newActive);\n      },\n      children,\n      parents\n    }\n  };\n  provide(VNestedSymbol, nested);\n  return nested.root;\n};\nexport const useNestedItem = id => {\n  const parent = inject(VNestedSymbol, emptyNested);\n  const computedId = computed(() => {\n    var _id$value;\n\n    return (_id$value = id.value) != null ? _id$value : getUid().toString();\n  });\n  const item = { ...parent,\n    id: computedId,\n    parent: computed(() => parent.root.parents.value.get(computedId.value)),\n    select: (selected, e) => parent.root.select(computedId.value, selected, e),\n    isSelected: computed(() => parent.root.selected.value.get(computedId.value) === 'on'),\n    activate: (activated, e) => parent.root.activate(computedId.value, activated, e),\n    isActive: computed(() => parent.root.active.value.has(computedId.value))\n  };\n  parent.root.register(computedId.value, parent.id.value, false);\n  onBeforeUnmount(() => {\n    parent.root.unregister(computedId.value);\n  });\n  return item;\n};\nexport const useNestedGroup = props => {\n  const parent = inject(VNestedSymbol, emptyNested);\n  const id = computed(() => {\n    var _props$value;\n\n    return (_props$value = props.value) != null ? _props$value : getUid().toString();\n  });\n  const group = { ...parent,\n    id,\n    open: (open, e) => parent.root.open(id.value, open, e),\n    isOpen: computed(() => parent.root.opened.value.has(id.value)),\n    isSelected: computed(() => parent.root.selected.value.get(id.value) === 'on'),\n    isIndeterminate: computed(() => parent.root.selected.value.get(id.value) === 'indeterminate')\n  };\n  parent.root.register(id.value, parent.id.value, true);\n  onBeforeUnmount(() => {\n    parent.root.unregister(id.value);\n  });\n  provide(VNestedSymbol, group);\n  return group;\n};","map":{"version":3,"mappings":"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","names":["useProxiedModel","getUid","propsFactory","computed","inject","onBeforeUnmount","provide","ref","multipleOpenStrategy","singleOpenStrategy","classicSelectStrategy","independentSelectStrategy","leafSelectStrategy","classicActiveStrategy","VNestedSymbol","Symbol","for","emptyNested","id","root","register","unregister","parents","Map","children","open","select","opened","Set","selected","active","activate","selectedValues","makeNestedProps","selectStrategy","String","Function","openStrategy","activeStrategy","Array","useNested","props","isUnmounted","v","values","value","in","out","nested","arr","key","entries","push","parentId","isGroup","set","get","delete","parent","list","filter","child","event","newOpened","newSelected","newActive","useNestedItem","computedId","toString","item","e","isSelected","activated","isActive","has","useNestedGroup","group","isOpen","isIndeterminate"],"sources":["../../../src/composables/nested/nested.ts"],"sourcesContent":["import { useProxiedModel } from '@/composables/proxiedModel'\nimport { getUid, propsFactory } from '@/util'\nimport { computed, inject, onBeforeUnmount, provide, ref } from 'vue'\nimport { multipleOpenStrategy, singleOpenStrategy } from './openStrategies'\nimport { classicSelectStrategy, independentSelectStrategy, leafSelectStrategy } from './selectStrategies'\nimport { classicActiveStrategy } from './activeStrategies'\n\n// Types\nimport type { InjectionKey, Prop, Ref } from 'vue'\nimport type { SelectStrategyFn } from './selectStrategies'\nimport type { OpenStrategyFn } from './openStrategies'\nimport type { ActiveStrategyFn } from './activeStrategies'\n\nexport type SelectStrategy = 'single-leaf' | 'leaf' | 'independent' | 'classic' | SelectStrategyFn\nexport type OpenStrategy = 'single' | 'multiple' | OpenStrategyFn\nexport type ActiveStrategy = 'single' | 'multiple' | ActiveStrategyFn\n\nexport interface NestedProps {\n  selectStrategy: SelectStrategy | undefined\n  openStrategy: OpenStrategy | undefined\n  activeStrategy: ActiveStrategy | undefined\n  selected: string[] | undefined\n  opened: string[] | undefined\n  active: string[] | undefined\n  'onUpdate:selected': ((val: string[]) => void) | undefined\n  'onUpdate:opened': ((val: string[]) => void) | undefined\n  'onUpdate:active': ((val: string[]) => void) | undefined\n}\n\ntype NestedProvide = {\n  id: Ref<string | null>\n  root: {\n    children: Ref<Map<string, string[]>>\n    parents: Ref<Map<string, string>>\n    opened: Ref<Set<string>>\n    active: Ref<Set<string>>\n    selected: Ref<Map<string, 'on' | 'off' | 'indeterminate'>>\n    selectedValues: Ref<string[]>\n    register: (id: string, parentId: string | null, isGroup?: boolean) => void\n    unregister: (id: string) => void\n    open: (id: string, value: boolean, event?: Event) => void\n    select: (id: string, value: boolean, event?: Event) => void\n    activate: (id: string, value: boolean, event?: Event) => void\n  }\n}\n\nconst VNestedSymbol: InjectionKey<NestedProvide> = Symbol.for('vuetify:nested')\n\nconst emptyNested: NestedProvide = {\n  id: ref(null),\n  root: {\n    register: () => null,\n    unregister: () => null,\n    parents: ref(new Map()),\n    children: ref(new Map()),\n    open: () => null,\n    select: () => null,\n    opened: ref(new Set()),\n    selected: ref(new Map()),\n    active: ref(new Set()),\n    activate: () => null,\n    selectedValues: ref([]),\n  },\n}\n\nexport const makeNestedProps = propsFactory({\n  selectStrategy: [String, Function] as Prop<SelectStrategy>,\n  openStrategy: [String, Function] as Prop<OpenStrategy>,\n  activeStrategy: [String, Function] as Prop<ActiveStrategy>,\n  opened: Array as Prop<string[]>,\n  selected: Array as Prop<string[]>,\n  active: Array as Prop<string[]>,\n}, 'nested')\n\nexport const useNested = (props: NestedProps) => {\n  let isUnmounted = false\n  const children = ref(new Map<string, string[]>())\n  const parents = ref(new Map<string, string>())\n\n  const opened = useProxiedModel(props, 'opened', props.opened, v => new Set(v), v => [...v.values()])\n  const active = useProxiedModel(props, 'active', props.active, v => new Set(v), v => [...v.values()])\n\n  const activeStrategy = computed(() => {\n    if (typeof props.activeStrategy === 'object') return props.activeStrategy\n\n    switch (props.activeStrategy) {\n      case 'single': return classicActiveStrategy(true)\n      case 'multiple':\n      default:\n        return classicActiveStrategy()\n    }\n  })\n\n  const selectStrategy = computed(() => {\n    if (typeof props.selectStrategy === 'object') return props.selectStrategy\n\n    switch (props.selectStrategy) {\n      case 'single-leaf': return leafSelectStrategy(true)\n      case 'leaf': return leafSelectStrategy()\n      case 'independent': return independentSelectStrategy\n      case 'classic':\n      default: return classicSelectStrategy\n    }\n  })\n\n  const openStrategy = computed(() => {\n    if (typeof props.openStrategy === 'function') return props.openStrategy\n\n    switch (props.openStrategy) {\n      case 'single': return singleOpenStrategy\n      case 'multiple':\n      default: return multipleOpenStrategy\n    }\n  })\n\n  const selected = useProxiedModel(\n    props,\n    'selected',\n    props.selected,\n    v => selectStrategy.value.in(v, children.value, parents.value),\n    v => selectStrategy.value.out(v, children.value, parents.value),\n  )\n\n  onBeforeUnmount(() => {\n    isUnmounted = true\n  })\n\n  const nested: NestedProvide = {\n    id: ref(null),\n    root: {\n      opened,\n      selected,\n      active,\n      selectedValues: computed(() => {\n        const arr = []\n\n        for (const [key, value] of selected.value.entries()) {\n          if (value === 'on') arr.push(key)\n        }\n\n        return arr\n      }),\n      register: (id, parentId, isGroup) => {\n        parentId && parents.value.set(id, parentId)\n\n        isGroup && children.value.set(id, [])\n\n        if (parentId != null) {\n          children.value.set(parentId, [...children.value.get(parentId) || [], id])\n        }\n      },\n      unregister: id => {\n        if (isUnmounted) return\n\n        children.value.delete(id)\n        const parent = parents.value.get(id)\n        if (parent) {\n          const list = children.value.get(parent) ?? []\n          children.value.set(parent, list.filter(child => child !== id))\n        }\n        parents.value.delete(id)\n        opened.value.delete(id)\n        active.value.delete(id)\n        selected.value.delete(id)\n      },\n      open: (id, value, event) => {\n        const newOpened = openStrategy.value({\n          id,\n          value,\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n\n        newOpened && (opened.value = newOpened)\n      },\n      select: (id, value, event) => {\n        const newSelected = selectStrategy.value.select({\n          id,\n          value,\n          selected: new Map(selected.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n\n        newSelected && (selected.value = newSelected)\n      },\n      activate: (id, value, event) => {\n        const newActive = activeStrategy.value({\n          id,\n          value,\n          active: new Set(active.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n\n        newActive && (active.value = newActive)\n      },\n      children,\n      parents,\n    },\n  }\n\n  provide(VNestedSymbol, nested)\n\n  return nested.root\n}\n\nexport const useNestedItem = (id: Ref<string | undefined>) => {\n  const parent = inject(VNestedSymbol, emptyNested)\n\n  const computedId = computed(() => id.value ?? getUid().toString())\n\n  const item = {\n    ...parent,\n    id: computedId,\n    parent: computed(() => parent.root.parents.value.get(computedId.value)),\n    select: (selected: boolean, e: Event) => parent.root.select(computedId.value, selected, e),\n    isSelected: computed(() => parent.root.selected.value.get(computedId.value) === 'on'),\n    activate: (activated: boolean, e: Event) => parent.root.activate(computedId.value, activated, e),\n    isActive: computed(() => parent.root.active.value.has(computedId.value)),\n  }\n\n  parent.root.register(computedId.value, parent.id.value, false)\n\n  onBeforeUnmount(() => {\n    parent.root.unregister(computedId.value)\n  })\n\n  return item\n}\n\nexport const useNestedGroup = (props: { value: string }) => {\n  const parent = inject(VNestedSymbol, emptyNested)\n\n  const id = computed(() => props.value ?? getUid().toString())\n\n  const group = {\n    ...parent,\n    id,\n    open: (open: boolean, e: Event) => parent.root.open(id.value, open, e),\n    isOpen: computed(() => parent.root.opened.value.has(id.value)),\n    isSelected: computed(() => parent.root.selected.value.get(id.value) === 'on'),\n    isIndeterminate: computed(() => parent.root.selected.value.get(id.value) === 'indeterminate'),\n  }\n\n  parent.root.register(id.value, parent.id.value, true)\n\n  onBeforeUnmount(() => {\n    parent.root.unregister(id.value)\n  })\n\n  provide(VNestedSymbol, group)\n\n  return group\n}\n"]},"metadata":{},"sourceType":"module"}