{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\n// This file was copied from https://github.com/substack/node-bufferlist\n// and modified to be able to copy bytes from the bufferlist directly into\n// a pre-existing fixed-size buffer without an additional memory allocation.\n// bufferlist.js\n// Treat a linked list of buffers as a single variable-size buffer.\nvar Buffer = require('buffer').Buffer;\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar bufferAllocUnsafe = require('../lib/utils').bufferAllocUnsafe;\n\nmodule.exports = BufferList;\nmodule.exports.BufferList = BufferList; // backwards compatibility\n\nfunction BufferList(opts) {\n  if (!(this instanceof BufferList)) return new BufferList(opts);\n  EventEmitter.call(this);\n  var self = this;\n  if (typeof opts == 'undefined') opts = {}; // default encoding to use for take(). Leaving as 'undefined'\n  // makes take() return a Buffer instead.\n\n  self.encoding = opts.encoding;\n  var head = {\n    next: null,\n    buffer: null\n  };\n  var last = {\n    next: null,\n    buffer: null\n  }; // length can get negative when advanced past the end\n  // and this is the desired behavior\n\n  var length = 0;\n\n  self.__defineGetter__('length', function () {\n    return length;\n  }); // keep an offset of the head to decide when to head = head.next\n\n\n  var offset = 0; // Write to the bufferlist. Emits 'write'. Always returns true.\n\n  self.write = function (buf) {\n    if (!head.buffer) {\n      head.buffer = buf;\n      last = head;\n    } else {\n      last.next = {\n        next: null,\n        buffer: buf\n      };\n      last = last.next;\n    }\n\n    length += buf.length;\n    self.emit('write', buf);\n    return true;\n  };\n\n  self.end = function (buf) {\n    if (Buffer.isBuffer(buf)) self.write(buf);\n  }; // Push buffers to the end of the linked list. (deprecated)\n  // Return this (self).\n\n\n  self.push = function () {\n    var args = [].concat.apply([], arguments);\n    args.forEach(self.write);\n    return self;\n  }; // For each buffer, perform some action.\n  // If fn's result is a true value, cut out early.\n  // Returns this (self).\n\n\n  self.forEach = function (fn) {\n    if (!head.buffer) return bufferAllocUnsafe(0);\n    if (head.buffer.length - offset <= 0) return self;\n    var firstBuf = head.buffer.slice(offset);\n    var b = {\n      buffer: firstBuf,\n      next: head.next\n    };\n\n    while (b && b.buffer) {\n      var r = fn(b.buffer);\n      if (r) break;\n      b = b.next;\n    }\n\n    return self;\n  }; // Create a single Buffer out of all the chunks or some subset specified by\n  // start and one-past the end (like slice) in bytes.\n\n\n  self.join = function (start, end) {\n    if (!head.buffer) return bufferAllocUnsafe(0);\n    if (start == undefined) start = 0;\n    if (end == undefined) end = self.length;\n    var big = bufferAllocUnsafe(end - start);\n    var ix = 0;\n    self.forEach(function (buffer) {\n      if (start < ix + buffer.length && ix < end) {\n        // at least partially contained in the range\n        buffer.copy(big, Math.max(0, ix - start), Math.max(0, start - ix), Math.min(buffer.length, end - ix));\n      }\n\n      ix += buffer.length;\n      if (ix > end) return true; // stop processing past end\n    });\n    return big;\n  };\n\n  self.joinInto = function (targetBuffer, targetStart, sourceStart, sourceEnd) {\n    if (!head.buffer) return new bufferAllocUnsafe(0);\n    if (sourceStart == undefined) sourceStart = 0;\n    if (sourceEnd == undefined) sourceEnd = self.length;\n    var big = targetBuffer;\n\n    if (big.length - targetStart < sourceEnd - sourceStart) {\n      throw new Error(\"Insufficient space available in target Buffer.\");\n    }\n\n    var ix = 0;\n    self.forEach(function (buffer) {\n      if (sourceStart < ix + buffer.length && ix < sourceEnd) {\n        // at least partially contained in the range\n        buffer.copy(big, Math.max(targetStart, targetStart + ix - sourceStart), Math.max(0, sourceStart - ix), Math.min(buffer.length, sourceEnd - ix));\n      }\n\n      ix += buffer.length;\n      if (ix > sourceEnd) return true; // stop processing past end\n    });\n    return big;\n  }; // Advance the buffer stream by n bytes.\n  // If n the aggregate advance offset passes the end of the buffer list,\n  // operations such as .take() will return empty strings until enough data is\n  // pushed.\n  // Returns this (self).\n\n\n  self.advance = function (n) {\n    offset += n;\n    length -= n;\n\n    while (head.buffer && offset >= head.buffer.length) {\n      offset -= head.buffer.length;\n      head = head.next ? head.next : {\n        buffer: null,\n        next: null\n      };\n    }\n\n    if (head.buffer === null) last = {\n      next: null,\n      buffer: null\n    };\n    self.emit('advance', n);\n    return self;\n  }; // Take n bytes from the start of the buffers.\n  // Returns a string.\n  // If there are less than n bytes in all the buffers or n is undefined,\n  // returns the entire concatenated buffer string.\n\n\n  self.take = function (n, encoding) {\n    if (n == undefined) n = self.length;else if (typeof n !== 'number') {\n      encoding = n;\n      n = self.length;\n    }\n    var b = head;\n    if (!encoding) encoding = self.encoding;\n\n    if (encoding) {\n      var acc = '';\n      self.forEach(function (buffer) {\n        if (n <= 0) return true;\n        acc += buffer.toString(encoding, 0, Math.min(n, buffer.length));\n        n -= buffer.length;\n      });\n      return acc;\n    } else {\n      // If no 'encoding' is specified, then return a Buffer.\n      return self.join(0, n);\n    }\n  }; // The entire concatenated buffer as a string.\n\n\n  self.toString = function () {\n    return self.take('binary');\n  };\n}\n\nrequire('util').inherits(BufferList, EventEmitter);","map":{"version":3,"sources":["/home/thaumy/Desktop/idb5-ui/node_modules/websocket/vendor/FastBufferList.js"],"names":["Buffer","require","EventEmitter","bufferAllocUnsafe","module","exports","BufferList","opts","call","self","encoding","head","next","buffer","last","length","__defineGetter__","offset","write","buf","emit","end","isBuffer","push","args","concat","apply","arguments","forEach","fn","firstBuf","slice","b","r","join","start","undefined","big","ix","copy","Math","max","min","joinInto","targetBuffer","targetStart","sourceStart","sourceEnd","Error","advance","n","take","acc","toString","inherits"],"mappings":"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","sourcesContent":["// This file was copied from https://github.com/substack/node-bufferlist\n// and modified to be able to copy bytes from the bufferlist directly into\n// a pre-existing fixed-size buffer without an additional memory allocation.\n\n// bufferlist.js\n// Treat a linked list of buffers as a single variable-size buffer.\nvar Buffer = require('buffer').Buffer;\nvar EventEmitter = require('events').EventEmitter;\nvar bufferAllocUnsafe = require('../lib/utils').bufferAllocUnsafe;\n\nmodule.exports = BufferList;\nmodule.exports.BufferList = BufferList; // backwards compatibility\n\nfunction BufferList(opts) {\n    if (!(this instanceof BufferList)) return new BufferList(opts);\n    EventEmitter.call(this);\n    var self = this;\n    \n    if (typeof(opts) == 'undefined') opts = {};\n    \n    // default encoding to use for take(). Leaving as 'undefined'\n    // makes take() return a Buffer instead.\n    self.encoding = opts.encoding;\n    \n    var head = { next : null, buffer : null };\n    var last = { next : null, buffer : null };\n    \n    // length can get negative when advanced past the end\n    // and this is the desired behavior\n    var length = 0;\n    self.__defineGetter__('length', function () {\n        return length;\n    });\n    \n    // keep an offset of the head to decide when to head = head.next\n    var offset = 0;\n    \n    // Write to the bufferlist. Emits 'write'. Always returns true.\n    self.write = function (buf) {\n        if (!head.buffer) {\n            head.buffer = buf;\n            last = head;\n        }\n        else {\n            last.next = { next : null, buffer : buf };\n            last = last.next;\n        }\n        length += buf.length;\n        self.emit('write', buf);\n        return true;\n    };\n    \n    self.end = function (buf) {\n        if (Buffer.isBuffer(buf)) self.write(buf);\n    };\n    \n    // Push buffers to the end of the linked list. (deprecated)\n    // Return this (self).\n    self.push = function () {\n        var args = [].concat.apply([], arguments);\n        args.forEach(self.write);\n        return self;\n    };\n    \n    // For each buffer, perform some action.\n    // If fn's result is a true value, cut out early.\n    // Returns this (self).\n    self.forEach = function (fn) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        \n        if (head.buffer.length - offset <= 0) return self;\n        var firstBuf = head.buffer.slice(offset);\n        \n        var b = { buffer : firstBuf, next : head.next };\n        \n        while (b && b.buffer) {\n            var r = fn(b.buffer);\n            if (r) break;\n            b = b.next;\n        }\n        \n        return self;\n    };\n    \n    // Create a single Buffer out of all the chunks or some subset specified by\n    // start and one-past the end (like slice) in bytes.\n    self.join = function (start, end) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        if (start == undefined) start = 0;\n        if (end == undefined) end = self.length;\n        \n        var big = bufferAllocUnsafe(end - start);\n        var ix = 0;\n        self.forEach(function (buffer) {\n            if (start < (ix + buffer.length) && ix < end) {\n                // at least partially contained in the range\n                buffer.copy(\n                    big,\n                    Math.max(0, ix - start),\n                    Math.max(0, start - ix),\n                    Math.min(buffer.length, end - ix)\n                );\n            }\n            ix += buffer.length;\n            if (ix > end) return true; // stop processing past end\n        });\n        \n        return big;\n    };\n    \n    self.joinInto = function (targetBuffer, targetStart, sourceStart, sourceEnd) {\n        if (!head.buffer) return new bufferAllocUnsafe(0);\n        if (sourceStart == undefined) sourceStart = 0;\n        if (sourceEnd == undefined) sourceEnd = self.length;\n        \n        var big = targetBuffer;\n        if (big.length - targetStart < sourceEnd - sourceStart) {\n            throw new Error(\"Insufficient space available in target Buffer.\");\n        }\n        var ix = 0;\n        self.forEach(function (buffer) {\n            if (sourceStart < (ix + buffer.length) && ix < sourceEnd) {\n                // at least partially contained in the range\n                buffer.copy(\n                    big,\n                    Math.max(targetStart, targetStart + ix - sourceStart),\n                    Math.max(0, sourceStart - ix),\n                    Math.min(buffer.length, sourceEnd - ix)\n                );\n            }\n            ix += buffer.length;\n            if (ix > sourceEnd) return true; // stop processing past end\n        });\n        \n        return big;\n    };\n    \n    // Advance the buffer stream by n bytes.\n    // If n the aggregate advance offset passes the end of the buffer list,\n    // operations such as .take() will return empty strings until enough data is\n    // pushed.\n    // Returns this (self).\n    self.advance = function (n) {\n        offset += n;\n        length -= n;\n        while (head.buffer && offset >= head.buffer.length) {\n            offset -= head.buffer.length;\n            head = head.next\n                ? head.next\n                : { buffer : null, next : null }\n            ;\n        }\n        if (head.buffer === null) last = { next : null, buffer : null };\n        self.emit('advance', n);\n        return self;\n    };\n    \n    // Take n bytes from the start of the buffers.\n    // Returns a string.\n    // If there are less than n bytes in all the buffers or n is undefined,\n    // returns the entire concatenated buffer string.\n    self.take = function (n, encoding) {\n        if (n == undefined) n = self.length;\n        else if (typeof n !== 'number') {\n            encoding = n;\n            n = self.length;\n        }\n        var b = head;\n        if (!encoding) encoding = self.encoding;\n        if (encoding) {\n            var acc = '';\n            self.forEach(function (buffer) {\n                if (n <= 0) return true;\n                acc += buffer.toString(\n                    encoding, 0, Math.min(n,buffer.length)\n                );\n                n -= buffer.length;\n            });\n            return acc;\n        } else {\n            // If no 'encoding' is specified, then return a Buffer.\n            return self.join(0, n);\n        }\n    };\n    \n    // The entire concatenated buffer as a string.\n    self.toString = function () {\n        return self.take('binary');\n    };\n}\nrequire('util').inherits(BufferList, EventEmitter);\n"]},"metadata":{},"sourceType":"script"}