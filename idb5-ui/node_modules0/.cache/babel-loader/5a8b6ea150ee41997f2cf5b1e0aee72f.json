{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\n/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\nvar extend = require('./utils').extend;\n\nvar util = require('util');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar WebSocketRouterRequest = require('./WebSocketRouterRequest');\n\nfunction WebSocketRouter(config) {\n  // Superclass Constructor\n  EventEmitter.call(this);\n  this.config = {\n    // The WebSocketServer instance to attach to.\n    server: null\n  };\n\n  if (config) {\n    extend(this.config, config);\n  }\n\n  this.handlers = [];\n  this._requestHandler = this.handleRequest.bind(this);\n\n  if (this.config.server) {\n    this.attachServer(this.config.server);\n  }\n}\n\nutil.inherits(WebSocketRouter, EventEmitter);\n\nWebSocketRouter.prototype.attachServer = function (server) {\n  if (server) {\n    this.server = server;\n    this.server.on('request', this._requestHandler);\n  } else {\n    throw new Error('You must specify a WebSocketServer instance to attach to.');\n  }\n};\n\nWebSocketRouter.prototype.detachServer = function () {\n  if (this.server) {\n    this.server.removeListener('request', this._requestHandler);\n    this.server = null;\n  } else {\n    throw new Error('Cannot detach from server: not attached.');\n  }\n};\n\nWebSocketRouter.prototype.mount = function (path, protocol, callback) {\n  if (!path) {\n    throw new Error('You must specify a path for this handler.');\n  }\n\n  if (!protocol) {\n    protocol = '____no_protocol____';\n  }\n\n  if (!callback) {\n    throw new Error('You must specify a callback for this handler.');\n  }\n\n  path = this.pathToRegExp(path);\n\n  if (!(path instanceof RegExp)) {\n    throw new Error('Path must be specified as either a string or a RegExp.');\n  }\n\n  var pathString = path.toString(); // normalize protocol to lower-case\n\n  protocol = protocol.toLocaleLowerCase();\n\n  if (this.findHandlerIndex(pathString, protocol) !== -1) {\n    throw new Error('You may only mount one handler per path/protocol combination.');\n  }\n\n  this.handlers.push({\n    'path': path,\n    'pathString': pathString,\n    'protocol': protocol,\n    'callback': callback\n  });\n};\n\nWebSocketRouter.prototype.unmount = function (path, protocol) {\n  var index = this.findHandlerIndex(this.pathToRegExp(path).toString(), protocol);\n\n  if (index !== -1) {\n    this.handlers.splice(index, 1);\n  } else {\n    throw new Error('Unable to find a route matching the specified path and protocol.');\n  }\n};\n\nWebSocketRouter.prototype.findHandlerIndex = function (pathString, protocol) {\n  protocol = protocol.toLocaleLowerCase();\n\n  for (var i = 0, len = this.handlers.length; i < len; i++) {\n    var handler = this.handlers[i];\n\n    if (handler.pathString === pathString && handler.protocol === protocol) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\nWebSocketRouter.prototype.pathToRegExp = function (path) {\n  if (typeof path === 'string') {\n    if (path === '*') {\n      path = /^.*$/;\n    } else {\n      path = path.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n      path = new RegExp('^' + path + '$');\n    }\n  }\n\n  return path;\n};\n\nWebSocketRouter.prototype.handleRequest = function (request) {\n  var requestedProtocols = request.requestedProtocols;\n\n  if (requestedProtocols.length === 0) {\n    requestedProtocols = ['____no_protocol____'];\n  } // Find a handler with the first requested protocol first\n\n\n  for (var i = 0; i < requestedProtocols.length; i++) {\n    var requestedProtocol = requestedProtocols[i].toLocaleLowerCase(); // find the first handler that can process this request\n\n    for (var j = 0, len = this.handlers.length; j < len; j++) {\n      var handler = this.handlers[j];\n\n      if (handler.path.test(request.resourceURL.pathname)) {\n        if (requestedProtocol === handler.protocol || handler.protocol === '*') {\n          var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);\n          handler.callback(routerRequest);\n          return;\n        }\n      }\n    }\n  } // If we get here we were unable to find a suitable handler.\n\n\n  request.reject(404, 'No handler is available for the given request.');\n};\n\nmodule.exports = WebSocketRouter;","map":{"version":3,"sources":["/home/thaumy/Desktop/idb5-ui/node_modules/websocket/lib/WebSocketRouter.js"],"names":["extend","require","util","EventEmitter","WebSocketRouterRequest","WebSocketRouter","config","call","server","handlers","_requestHandler","handleRequest","bind","attachServer","inherits","prototype","on","Error","detachServer","removeListener","mount","path","protocol","callback","pathToRegExp","RegExp","pathString","toString","toLocaleLowerCase","findHandlerIndex","push","unmount","index","splice","i","len","length","handler","replace","request","requestedProtocols","requestedProtocol","j","test","resourceURL","pathname","routerRequest","reject","module","exports"],"mappings":"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","sourcesContent":["/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar extend = require('./utils').extend;\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar WebSocketRouterRequest = require('./WebSocketRouterRequest');\n\nfunction WebSocketRouter(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this.config = {\n        // The WebSocketServer instance to attach to.\n        server: null\n    };\n    if (config) {\n        extend(this.config, config);\n    }\n    this.handlers = [];\n\n    this._requestHandler = this.handleRequest.bind(this);\n    if (this.config.server) {\n        this.attachServer(this.config.server);\n    }\n}\n\nutil.inherits(WebSocketRouter, EventEmitter);\n\nWebSocketRouter.prototype.attachServer = function(server) {\n    if (server) {\n        this.server = server;\n        this.server.on('request', this._requestHandler);\n    }\n    else {\n        throw new Error('You must specify a WebSocketServer instance to attach to.');\n    }\n};\n\nWebSocketRouter.prototype.detachServer = function() {\n    if (this.server) {\n        this.server.removeListener('request', this._requestHandler);\n        this.server = null;\n    }\n    else {\n        throw new Error('Cannot detach from server: not attached.');\n    }\n};\n\nWebSocketRouter.prototype.mount = function(path, protocol, callback) {\n    if (!path) {\n        throw new Error('You must specify a path for this handler.');\n    }\n    if (!protocol) {\n        protocol = '____no_protocol____';\n    }\n    if (!callback) {\n        throw new Error('You must specify a callback for this handler.');\n    }\n\n    path = this.pathToRegExp(path);\n    if (!(path instanceof RegExp)) {\n        throw new Error('Path must be specified as either a string or a RegExp.');\n    }\n    var pathString = path.toString();\n\n    // normalize protocol to lower-case\n    protocol = protocol.toLocaleLowerCase();\n\n    if (this.findHandlerIndex(pathString, protocol) !== -1) {\n        throw new Error('You may only mount one handler per path/protocol combination.');\n    }\n\n    this.handlers.push({\n        'path': path,\n        'pathString': pathString,\n        'protocol': protocol,\n        'callback': callback\n    });\n};\nWebSocketRouter.prototype.unmount = function(path, protocol) {\n    var index = this.findHandlerIndex(this.pathToRegExp(path).toString(), protocol);\n    if (index !== -1) {\n        this.handlers.splice(index, 1);\n    }\n    else {\n        throw new Error('Unable to find a route matching the specified path and protocol.');\n    }\n};\n\nWebSocketRouter.prototype.findHandlerIndex = function(pathString, protocol) {\n    protocol = protocol.toLocaleLowerCase();\n    for (var i=0, len=this.handlers.length; i < len; i++) {\n        var handler = this.handlers[i];\n        if (handler.pathString === pathString && handler.protocol === protocol) {\n            return i;\n        }\n    }\n    return -1;\n};\n\nWebSocketRouter.prototype.pathToRegExp = function(path) {\n    if (typeof(path) === 'string') {\n        if (path === '*') {\n            path = /^.*$/;\n        }\n        else {\n            path = path.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n            path = new RegExp('^' + path + '$');\n        }\n    }\n    return path;\n};\n\nWebSocketRouter.prototype.handleRequest = function(request) {\n    var requestedProtocols = request.requestedProtocols;\n    if (requestedProtocols.length === 0) {\n        requestedProtocols = ['____no_protocol____'];\n    }\n\n    // Find a handler with the first requested protocol first\n    for (var i=0; i < requestedProtocols.length; i++) {\n        var requestedProtocol = requestedProtocols[i].toLocaleLowerCase();\n\n        // find the first handler that can process this request\n        for (var j=0, len=this.handlers.length; j < len; j++) {\n            var handler = this.handlers[j];\n            if (handler.path.test(request.resourceURL.pathname)) {\n                if (requestedProtocol === handler.protocol ||\n                    handler.protocol === '*')\n                {\n                    var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);\n                    handler.callback(routerRequest);\n                    return;\n                }\n            }\n        }\n    }\n\n    // If we get here we were unable to find a suitable handler.\n    request.reject(404, 'No handler is available for the given request.');\n};\n\nmodule.exports = WebSocketRouter;\n"]},"metadata":{},"sourceType":"script"}