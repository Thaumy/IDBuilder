{"ast":null,"code":"require(\"core-js/modules/web.immediate.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\n/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\nvar util = require('util');\n\nvar utils = require('./utils');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar WebSocketFrame = require('./WebSocketFrame');\n\nvar BufferList = require('../vendor/FastBufferList');\n\nvar isValidUTF8 = require('utf-8-validate');\n\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\nvar bufferFromString = utils.bufferFromString; // Connected, fully-open, ready to send and receive frames\n\nconst STATE_OPEN = 'open'; // Received a close frame from the remote peer\n\nconst STATE_PEER_REQUESTED_CLOSE = 'peer_requested_close'; // Sent close frame to remote peer.  No further data can be sent.\n\nconst STATE_ENDING = 'ending'; // Connection is fully closed.  No further data can be sent or received.\n\nconst STATE_CLOSED = 'closed';\nvar setImmediateImpl = 'setImmediate' in global ? global.setImmediate.bind(global) : process.nextTick.bind(process);\nvar idCounter = 0;\n\nfunction WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {\n  this._debug = utils.BufferingLogger('websocket:connection', ++idCounter);\n\n  this._debug('constructor');\n\n  if (this._debug.enabled) {\n    instrumentSocketForDebugging(this, socket);\n  } // Superclass Constructor\n\n\n  EventEmitter.call(this);\n  this._pingListenerCount = 0;\n  this.on('newListener', function (ev) {\n    if (ev === 'ping') {\n      this._pingListenerCount++;\n    }\n  }).on('removeListener', function (ev) {\n    if (ev === 'ping') {\n      this._pingListenerCount--;\n    }\n  });\n  this.config = config;\n  this.socket = socket;\n  this.protocol = protocol;\n  this.extensions = extensions;\n  this.remoteAddress = socket.remoteAddress;\n  this.closeReasonCode = -1;\n  this.closeDescription = null;\n  this.closeEventEmitted = false; // We have to mask outgoing packets if we're acting as a WebSocket client.\n\n  this.maskOutgoingPackets = maskOutgoingPackets; // We re-use the same buffers for the mask and frame header for all frames\n  // received on each connection to avoid a small memory allocation for each\n  // frame.\n\n  this.maskBytes = bufferAllocUnsafe(4);\n  this.frameHeader = bufferAllocUnsafe(10); // the BufferList will handle the data streaming in\n\n  this.bufferList = new BufferList(); // Prepare for receiving first frame\n\n  this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n  this.fragmentationSize = 0; // data received so far...\n\n  this.frameQueue = []; // Various bits of connection state\n\n  this.connected = true;\n  this.state = STATE_OPEN;\n  this.waitingForCloseResponse = false; // Received TCP FIN, socket's readable stream is finished.\n\n  this.receivedEnd = false;\n  this.closeTimeout = this.config.closeTimeout;\n  this.assembleFragments = this.config.assembleFragments;\n  this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;\n  this.outputBufferFull = false;\n  this.inputPaused = false;\n  this.receivedDataHandler = this.processReceivedData.bind(this);\n  this._closeTimerHandler = this.handleCloseTimer.bind(this); // Disable nagle algorithm?\n\n  this.socket.setNoDelay(this.config.disableNagleAlgorithm); // Make sure there is no socket inactivity timeout\n\n  this.socket.setTimeout(0);\n\n  if (this.config.keepalive && !this.config.useNativeKeepalive) {\n    if (typeof this.config.keepaliveInterval !== 'number') {\n      throw new Error('keepaliveInterval must be specified and numeric ' + 'if keepalive is true.');\n    }\n\n    this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);\n    this.setKeepaliveTimer();\n\n    if (this.config.dropConnectionOnKeepaliveTimeout) {\n      if (typeof this.config.keepaliveGracePeriod !== 'number') {\n        throw new Error('keepaliveGracePeriod  must be specified and ' + 'numeric if dropConnectionOnKeepaliveTimeout ' + 'is true.');\n      }\n\n      this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);\n    }\n  } else if (this.config.keepalive && this.config.useNativeKeepalive) {\n    if (!('setKeepAlive' in this.socket)) {\n      throw new Error('Unable to use native keepalive: unsupported by ' + 'this version of Node.');\n    }\n\n    this.socket.setKeepAlive(true, this.config.keepaliveInterval);\n  } // The HTTP Client seems to subscribe to socket error events\n  // and re-dispatch them in such a way that doesn't make sense\n  // for users of our client, so we want to make sure nobody\n  // else is listening for error events on the socket besides us.\n\n\n  this.socket.removeAllListeners('error');\n}\n\nWebSocketConnection.CLOSE_REASON_NORMAL = 1000;\nWebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;\nWebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;\nWebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;\nWebSocketConnection.CLOSE_REASON_RESERVED = 1004; // Reserved value.  Undefined meaning.\n\nWebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005; // Not to be used on the wire\n\nWebSocketConnection.CLOSE_REASON_ABNORMAL = 1006; // Not to be used on the wire\n\nWebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;\nWebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;\nWebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;\nWebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;\nWebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;\nWebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015; // Not to be used on the wire\n\nWebSocketConnection.CLOSE_DESCRIPTIONS = {\n  1000: 'Normal connection closure',\n  1001: 'Remote peer is going away',\n  1002: 'Protocol error',\n  1003: 'Unprocessable input',\n  1004: 'Reserved',\n  1005: 'Reason not provided',\n  1006: 'Abnormal closure, no further detail available',\n  1007: 'Invalid data received',\n  1008: 'Policy violation',\n  1009: 'Message too big',\n  1010: 'Extension requested by client is required',\n  1011: 'Internal Server Error',\n  1015: 'TLS Handshake Failed'\n};\n\nfunction validateCloseReason(code) {\n  if (code < 1000) {\n    // Status codes in the range 0-999 are not used\n    return false;\n  }\n\n  if (code >= 1000 && code <= 2999) {\n    // Codes from 1000 - 2999 are reserved for use by the protocol.  Only\n    // a few codes are defined, all others are currently illegal.\n    return [1000, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015].indexOf(code) !== -1;\n  }\n\n  if (code >= 3000 && code <= 3999) {\n    // Reserved for use by libraries, frameworks, and applications.\n    // Should be registered with IANA.  Interpretation of these codes is\n    // undefined by the WebSocket protocol.\n    return true;\n  }\n\n  if (code >= 4000 && code <= 4999) {\n    // Reserved for private use.  Interpretation of these codes is\n    // undefined by the WebSocket protocol.\n    return true;\n  }\n\n  if (code >= 5000) {\n    return false;\n  }\n}\n\nutil.inherits(WebSocketConnection, EventEmitter);\n\nWebSocketConnection.prototype._addSocketEventListeners = function () {\n  this.socket.on('error', this.handleSocketError.bind(this));\n  this.socket.on('end', this.handleSocketEnd.bind(this));\n  this.socket.on('close', this.handleSocketClose.bind(this));\n  this.socket.on('drain', this.handleSocketDrain.bind(this));\n  this.socket.on('pause', this.handleSocketPause.bind(this));\n  this.socket.on('resume', this.handleSocketResume.bind(this));\n  this.socket.on('data', this.handleSocketData.bind(this));\n}; // set or reset the keepalive timer when data is received.\n\n\nWebSocketConnection.prototype.setKeepaliveTimer = function () {\n  this._debug('setKeepaliveTimer');\n\n  if (!this.config.keepalive || this.config.useNativeKeepalive) {\n    return;\n  }\n\n  this.clearKeepaliveTimer();\n  this.clearGracePeriodTimer();\n  this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);\n};\n\nWebSocketConnection.prototype.clearKeepaliveTimer = function () {\n  if (this._keepaliveTimeoutID) {\n    clearTimeout(this._keepaliveTimeoutID);\n  }\n}; // No data has been received within config.keepaliveTimeout ms.\n\n\nWebSocketConnection.prototype.handleKeepaliveTimer = function () {\n  this._debug('handleKeepaliveTimer');\n\n  this._keepaliveTimeoutID = null;\n  this.ping(); // If we are configured to drop connections if the client doesn't respond\n  // then set the grace period timer.\n\n  if (this.config.dropConnectionOnKeepaliveTimeout) {\n    this.setGracePeriodTimer();\n  } else {\n    // Otherwise reset the keepalive timer to send the next ping.\n    this.setKeepaliveTimer();\n  }\n};\n\nWebSocketConnection.prototype.setGracePeriodTimer = function () {\n  this._debug('setGracePeriodTimer');\n\n  this.clearGracePeriodTimer();\n  this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);\n};\n\nWebSocketConnection.prototype.clearGracePeriodTimer = function () {\n  if (this._gracePeriodTimeoutID) {\n    clearTimeout(this._gracePeriodTimeoutID);\n  }\n};\n\nWebSocketConnection.prototype.handleGracePeriodTimer = function () {\n  this._debug('handleGracePeriodTimer'); // If this is called, the client has not responded and is assumed dead.\n\n\n  this._gracePeriodTimeoutID = null;\n  this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, 'Peer not responding.', true);\n};\n\nWebSocketConnection.prototype.handleSocketData = function (data) {\n  this._debug('handleSocketData'); // Reset the keepalive timer when receiving data of any kind.\n\n\n  this.setKeepaliveTimer(); // Add received data to our bufferList, which efficiently holds received\n  // data chunks in a linked list of Buffer objects.\n\n  this.bufferList.write(data);\n  this.processReceivedData();\n};\n\nWebSocketConnection.prototype.processReceivedData = function () {\n  this._debug('processReceivedData'); // If we're not connected, we should ignore any data remaining on the buffer.\n\n\n  if (!this.connected) {\n    return;\n  } // Receiving/parsing is expected to be halted when paused.\n\n\n  if (this.inputPaused) {\n    return;\n  }\n\n  var frame = this.currentFrame; // WebSocketFrame.prototype.addData returns true if all data necessary to\n  // parse the frame was available.  It returns false if we are waiting for\n  // more data to come in on the wire.\n\n  if (!frame.addData(this.bufferList)) {\n    this._debug('-- insufficient data for frame');\n\n    return;\n  }\n\n  var self = this; // Handle possible parsing errors\n\n  if (frame.protocolError) {\n    // Something bad happened.. get rid of this client.\n    this._debug('-- protocol error');\n\n    process.nextTick(function () {\n      self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);\n    });\n    return;\n  } else if (frame.frameTooLarge) {\n    this._debug('-- frame too large');\n\n    process.nextTick(function () {\n      self.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);\n    });\n    return;\n  } // For now since we don't support extensions, all RSV bits are illegal\n\n\n  if (frame.rsv1 || frame.rsv2 || frame.rsv3) {\n    this._debug('-- illegal rsv flag');\n\n    process.nextTick(function () {\n      self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, 'Unsupported usage of rsv bits without negotiated extension.');\n    });\n    return;\n  }\n\n  if (!this.assembleFragments) {\n    this._debug('-- emitting frame');\n\n    process.nextTick(function () {\n      self.emit('frame', frame);\n    });\n  }\n\n  process.nextTick(function () {\n    self.processFrame(frame);\n  });\n  this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config); // If there's data remaining, schedule additional processing, but yield\n  // for now so that other connections have a chance to have their data\n  // processed.  We use setImmediate here instead of process.nextTick to\n  // explicitly indicate that we wish for other I/O to be handled first.\n\n  if (this.bufferList.length > 0) {\n    setImmediateImpl(this.receivedDataHandler);\n  }\n};\n\nWebSocketConnection.prototype.handleSocketError = function (error) {\n  this._debug('handleSocketError: %j', error);\n\n  if (this.state === STATE_CLOSED) {\n    // See https://github.com/theturtle32/WebSocket-Node/issues/288\n    this._debug('  --- Socket \\'error\\' after \\'close\\'');\n\n    return;\n  }\n\n  this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n  this.closeDescription = 'Socket Error: ' + error.syscall + ' ' + error.code;\n  this.connected = false;\n  this.state = STATE_CLOSED;\n  this.fragmentationSize = 0;\n\n  if (utils.eventEmitterListenerCount(this, 'error') > 0) {\n    this.emit('error', error);\n  }\n\n  this.socket.destroy();\n\n  this._debug.printOutput();\n};\n\nWebSocketConnection.prototype.handleSocketEnd = function () {\n  this._debug('handleSocketEnd: received socket end.  state = %s', this.state);\n\n  this.receivedEnd = true;\n\n  if (this.state === STATE_CLOSED) {\n    // When using the TLS module, sometimes the socket will emit 'end'\n    // after it emits 'close'.  I don't think that's correct behavior,\n    // but we should deal with it gracefully by ignoring it.\n    this._debug('  --- Socket \\'end\\' after \\'close\\'');\n\n    return;\n  }\n\n  if (this.state !== STATE_PEER_REQUESTED_CLOSE && this.state !== STATE_ENDING) {\n    this._debug('  --- UNEXPECTED socket end.');\n\n    this.socket.end();\n  }\n};\n\nWebSocketConnection.prototype.handleSocketClose = function (hadError) {\n  this._debug('handleSocketClose: received socket close');\n\n  this.socketHadError = hadError;\n  this.connected = false;\n  this.state = STATE_CLOSED; // If closeReasonCode is still set to -1 at this point then we must\n  // not have received a close frame!!\n\n  if (this.closeReasonCode === -1) {\n    this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n    this.closeDescription = 'Connection dropped by remote peer.';\n  }\n\n  this.clearCloseTimer();\n  this.clearKeepaliveTimer();\n  this.clearGracePeriodTimer();\n\n  if (!this.closeEventEmitted) {\n    this.closeEventEmitted = true;\n\n    this._debug('-- Emitting WebSocketConnection close event');\n\n    this.emit('close', this.closeReasonCode, this.closeDescription);\n  }\n};\n\nWebSocketConnection.prototype.handleSocketDrain = function () {\n  this._debug('handleSocketDrain: socket drain event');\n\n  this.outputBufferFull = false;\n  this.emit('drain');\n};\n\nWebSocketConnection.prototype.handleSocketPause = function () {\n  this._debug('handleSocketPause: socket pause event');\n\n  this.inputPaused = true;\n  this.emit('pause');\n};\n\nWebSocketConnection.prototype.handleSocketResume = function () {\n  this._debug('handleSocketResume: socket resume event');\n\n  this.inputPaused = false;\n  this.emit('resume');\n  this.processReceivedData();\n};\n\nWebSocketConnection.prototype.pause = function () {\n  this._debug('pause: pause requested');\n\n  this.socket.pause();\n};\n\nWebSocketConnection.prototype.resume = function () {\n  this._debug('resume: resume requested');\n\n  this.socket.resume();\n};\n\nWebSocketConnection.prototype.close = function (reasonCode, description) {\n  if (this.connected) {\n    this._debug('close: Initating clean WebSocket close sequence.');\n\n    if ('number' !== typeof reasonCode) {\n      reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n    }\n\n    if (!validateCloseReason(reasonCode)) {\n      throw new Error('Close code ' + reasonCode + ' is not valid.');\n    }\n\n    if ('string' !== typeof description) {\n      description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n    }\n\n    this.closeReasonCode = reasonCode;\n    this.closeDescription = description;\n    this.setCloseTimer();\n    this.sendCloseFrame(this.closeReasonCode, this.closeDescription);\n    this.state = STATE_ENDING;\n    this.connected = false;\n  }\n};\n\nWebSocketConnection.prototype.drop = function (reasonCode, description, skipCloseFrame) {\n  this._debug('drop');\n\n  if (typeof reasonCode !== 'number') {\n    reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n  }\n\n  if (typeof description !== 'string') {\n    // If no description is provided, try to look one up based on the\n    // specified reasonCode.\n    description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n  }\n\n  this._debug('Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s', skipCloseFrame, reasonCode, description);\n\n  this.closeReasonCode = reasonCode;\n  this.closeDescription = description;\n  this.frameQueue = [];\n  this.fragmentationSize = 0;\n\n  if (!skipCloseFrame) {\n    this.sendCloseFrame(reasonCode, description);\n  }\n\n  this.connected = false;\n  this.state = STATE_CLOSED;\n  this.clearCloseTimer();\n  this.clearKeepaliveTimer();\n  this.clearGracePeriodTimer();\n\n  if (!this.closeEventEmitted) {\n    this.closeEventEmitted = true;\n\n    this._debug('Emitting WebSocketConnection close event');\n\n    this.emit('close', this.closeReasonCode, this.closeDescription);\n  }\n\n  this._debug('Drop: destroying socket');\n\n  this.socket.destroy();\n};\n\nWebSocketConnection.prototype.setCloseTimer = function () {\n  this._debug('setCloseTimer');\n\n  this.clearCloseTimer();\n\n  this._debug('Setting close timer');\n\n  this.waitingForCloseResponse = true;\n  this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);\n};\n\nWebSocketConnection.prototype.clearCloseTimer = function () {\n  this._debug('clearCloseTimer');\n\n  if (this.closeTimer) {\n    this._debug('Clearing close timer');\n\n    clearTimeout(this.closeTimer);\n    this.waitingForCloseResponse = false;\n    this.closeTimer = null;\n  }\n};\n\nWebSocketConnection.prototype.handleCloseTimer = function () {\n  this._debug('handleCloseTimer');\n\n  this.closeTimer = null;\n\n  if (this.waitingForCloseResponse) {\n    this._debug('Close response not received from client.  Forcing socket end.');\n\n    this.waitingForCloseResponse = false;\n    this.state = STATE_CLOSED;\n    this.socket.end();\n  }\n};\n\nWebSocketConnection.prototype.processFrame = function (frame) {\n  this._debug('processFrame');\n\n  this._debug(' -- frame: %s', frame); // Any non-control opcode besides 0x00 (continuation) received in the\n  // middle of a fragmented message is illegal.\n\n\n  if (this.frameQueue.length !== 0 && frame.opcode > 0x00 && frame.opcode < 0x08) {\n    this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, 'Illegal frame opcode 0x' + frame.opcode.toString(16) + ' ' + 'received in middle of fragmented message.');\n    return;\n  }\n\n  switch (frame.opcode) {\n    case 0x02:\n      // WebSocketFrame.BINARY_FRAME\n      this._debug('-- Binary Frame');\n\n      if (this.assembleFragments) {\n        if (frame.fin) {\n          // Complete single-frame message received\n          this._debug('---- Emitting \\'message\\' event');\n\n          this.emit('message', {\n            type: 'binary',\n            binaryData: frame.binaryPayload\n          });\n        } else {\n          // beginning of a fragmented message\n          this.frameQueue.push(frame);\n          this.fragmentationSize = frame.length;\n        }\n      }\n\n      break;\n\n    case 0x01:\n      // WebSocketFrame.TEXT_FRAME\n      this._debug('-- Text Frame');\n\n      if (this.assembleFragments) {\n        if (frame.fin) {\n          if (!isValidUTF8(frame.binaryPayload)) {\n            this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, 'Invalid UTF-8 Data Received');\n            return;\n          } // Complete single-frame message received\n\n\n          this._debug('---- Emitting \\'message\\' event');\n\n          this.emit('message', {\n            type: 'utf8',\n            utf8Data: frame.binaryPayload.toString('utf8')\n          });\n        } else {\n          // beginning of a fragmented message\n          this.frameQueue.push(frame);\n          this.fragmentationSize = frame.length;\n        }\n      }\n\n      break;\n\n    case 0x00:\n      // WebSocketFrame.CONTINUATION\n      this._debug('-- Continuation Frame');\n\n      if (this.assembleFragments) {\n        if (this.frameQueue.length === 0) {\n          this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, 'Unexpected Continuation Frame');\n          return;\n        }\n\n        this.fragmentationSize += frame.length;\n\n        if (this.fragmentationSize > this.maxReceivedMessageSize) {\n          this.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, 'Maximum message size exceeded.');\n          return;\n        }\n\n        this.frameQueue.push(frame);\n\n        if (frame.fin) {\n          // end of fragmented message, so we process the whole\n          // message now.  We also have to decode the utf-8 data\n          // for text frames after combining all the fragments.\n          var bytesCopied = 0;\n          var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);\n          var opcode = this.frameQueue[0].opcode;\n          this.frameQueue.forEach(function (currentFrame) {\n            currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);\n            bytesCopied += currentFrame.binaryPayload.length;\n          });\n          this.frameQueue = [];\n          this.fragmentationSize = 0;\n\n          switch (opcode) {\n            case 0x02:\n              // WebSocketOpcode.BINARY_FRAME\n              this.emit('message', {\n                type: 'binary',\n                binaryData: binaryPayload\n              });\n              break;\n\n            case 0x01:\n              // WebSocketOpcode.TEXT_FRAME\n              if (!isValidUTF8(binaryPayload)) {\n                this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, 'Invalid UTF-8 Data Received');\n                return;\n              }\n\n              this.emit('message', {\n                type: 'utf8',\n                utf8Data: binaryPayload.toString('utf8')\n              });\n              break;\n\n            default:\n              this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, 'Unexpected first opcode in fragmentation sequence: 0x' + opcode.toString(16));\n              return;\n          }\n        }\n      }\n\n      break;\n\n    case 0x09:\n      // WebSocketFrame.PING\n      this._debug('-- Ping Frame');\n\n      if (this._pingListenerCount > 0) {\n        // logic to emit the ping frame: this is only done when a listener is known to exist\n        // Expose a function allowing the user to override the default ping() behavior\n        var cancelled = false;\n\n        var cancel = function () {\n          cancelled = true;\n        };\n\n        this.emit('ping', cancel, frame.binaryPayload); // Only send a pong if the client did not indicate that he would like to cancel\n\n        if (!cancelled) {\n          this.pong(frame.binaryPayload);\n        }\n      } else {\n        this.pong(frame.binaryPayload);\n      }\n\n      break;\n\n    case 0x0A:\n      // WebSocketFrame.PONG\n      this._debug('-- Pong Frame');\n\n      this.emit('pong', frame.binaryPayload);\n      break;\n\n    case 0x08:\n      // WebSocketFrame.CONNECTION_CLOSE\n      this._debug('-- Close Frame');\n\n      if (this.waitingForCloseResponse) {\n        // Got response to our request to close the connection.\n        // Close is complete, so we just hang up.\n        this._debug('---- Got close response from peer.  Completing closing handshake.');\n\n        this.clearCloseTimer();\n        this.waitingForCloseResponse = false;\n        this.state = STATE_CLOSED;\n        this.socket.end();\n        return;\n      }\n\n      this._debug('---- Closing handshake initiated by peer.'); // Got request from other party to close connection.\n      // Send back acknowledgement and then hang up.\n\n\n      this.state = STATE_PEER_REQUESTED_CLOSE;\n      var respondCloseReasonCode; // Make sure the close reason provided is legal according to\n      // the protocol spec.  Providing no close status is legal.\n      // WebSocketFrame sets closeStatus to -1 by default, so if it\n      // is still -1, then no status was provided.\n\n      if (frame.invalidCloseFrameLength) {\n        this.closeReasonCode = 1005; // 1005 = No reason provided.\n\n        respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n      } else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {\n        this.closeReasonCode = frame.closeStatus;\n        respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n      } else {\n        this.closeReasonCode = frame.closeStatus;\n        respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n      } // If there is a textual description in the close frame, extract it.\n\n\n      if (frame.binaryPayload.length > 1) {\n        if (!isValidUTF8(frame.binaryPayload)) {\n          this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, 'Invalid UTF-8 Data Received');\n          return;\n        }\n\n        this.closeDescription = frame.binaryPayload.toString('utf8');\n      } else {\n        this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];\n      }\n\n      this._debug('------ Remote peer %s - code: %d - %s - close frame payload length: %d', this.remoteAddress, this.closeReasonCode, this.closeDescription, frame.length);\n\n      this._debug('------ responding to remote peer\\'s close request.');\n\n      this.sendCloseFrame(respondCloseReasonCode, null);\n      this.connected = false;\n      break;\n\n    default:\n      this._debug('-- Unrecognized Opcode %d', frame.opcode);\n\n      this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, 'Unrecognized Opcode: 0x' + frame.opcode.toString(16));\n      break;\n  }\n};\n\nWebSocketConnection.prototype.send = function (data, cb) {\n  this._debug('send');\n\n  if (Buffer.isBuffer(data)) {\n    this.sendBytes(data, cb);\n  } else if (typeof data['toString'] === 'function') {\n    this.sendUTF(data, cb);\n  } else {\n    throw new Error('Data provided must either be a Node Buffer or implement toString()');\n  }\n};\n\nWebSocketConnection.prototype.sendUTF = function (data, cb) {\n  data = bufferFromString(data.toString(), 'utf8');\n\n  this._debug('sendUTF: %d bytes', data.length);\n\n  var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n  frame.opcode = 0x01; // WebSocketOpcode.TEXT_FRAME\n\n  frame.binaryPayload = data;\n  this.fragmentAndSend(frame, cb);\n};\n\nWebSocketConnection.prototype.sendBytes = function (data, cb) {\n  this._debug('sendBytes');\n\n  if (!Buffer.isBuffer(data)) {\n    throw new Error('You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()');\n  }\n\n  var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n  frame.opcode = 0x02; // WebSocketOpcode.BINARY_FRAME\n\n  frame.binaryPayload = data;\n  this.fragmentAndSend(frame, cb);\n};\n\nWebSocketConnection.prototype.ping = function (data) {\n  this._debug('ping');\n\n  var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n  frame.opcode = 0x09; // WebSocketOpcode.PING\n\n  frame.fin = true;\n\n  if (data) {\n    if (!Buffer.isBuffer(data)) {\n      data = bufferFromString(data.toString(), 'utf8');\n    }\n\n    if (data.length > 125) {\n      this._debug('WebSocket: Data for ping is longer than 125 bytes.  Truncating.');\n\n      data = data.slice(0, 124);\n    }\n\n    frame.binaryPayload = data;\n  }\n\n  this.sendFrame(frame);\n}; // Pong frames have to echo back the contents of the data portion of the\n// ping frame exactly, byte for byte.\n\n\nWebSocketConnection.prototype.pong = function (binaryPayload) {\n  this._debug('pong');\n\n  var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n  frame.opcode = 0x0A; // WebSocketOpcode.PONG\n\n  if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {\n    this._debug('WebSocket: Data for pong is longer than 125 bytes.  Truncating.');\n\n    binaryPayload = binaryPayload.slice(0, 124);\n  }\n\n  frame.binaryPayload = binaryPayload;\n  frame.fin = true;\n  this.sendFrame(frame);\n};\n\nWebSocketConnection.prototype.fragmentAndSend = function (frame, cb) {\n  this._debug('fragmentAndSend');\n\n  if (frame.opcode > 0x07) {\n    throw new Error('You cannot fragment control frames.');\n  }\n\n  var threshold = this.config.fragmentationThreshold;\n  var length = frame.binaryPayload.length; // Send immediately if fragmentation is disabled or the message is not\n  // larger than the fragmentation threshold.\n\n  if (!this.config.fragmentOutgoingMessages || frame.binaryPayload && length <= threshold) {\n    frame.fin = true;\n    this.sendFrame(frame, cb);\n    return;\n  }\n\n  var numFragments = Math.ceil(length / threshold);\n  var sentFragments = 0;\n\n  var sentCallback = function fragmentSentCallback(err) {\n    if (err) {\n      if (typeof cb === 'function') {\n        // pass only the first error\n        cb(err);\n        cb = null;\n      }\n\n      return;\n    }\n\n    ++sentFragments;\n\n    if (sentFragments === numFragments && typeof cb === 'function') {\n      cb();\n    }\n  };\n\n  for (var i = 1; i <= numFragments; i++) {\n    var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config); // continuation opcode except for first frame.\n\n    currentFrame.opcode = i === 1 ? frame.opcode : 0x00; // fin set on last frame only\n\n    currentFrame.fin = i === numFragments; // length is likely to be shorter on the last fragment\n\n    var currentLength = i === numFragments ? length - threshold * (i - 1) : threshold;\n    var sliceStart = threshold * (i - 1); // Slice the right portion of the original payload\n\n    currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);\n    this.sendFrame(currentFrame, sentCallback);\n  }\n};\n\nWebSocketConnection.prototype.sendCloseFrame = function (reasonCode, description, cb) {\n  if (typeof reasonCode !== 'number') {\n    reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n  }\n\n  this._debug('sendCloseFrame state: %s, reasonCode: %d, description: %s', this.state, reasonCode, description);\n\n  if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) {\n    return;\n  }\n\n  var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n  frame.fin = true;\n  frame.opcode = 0x08; // WebSocketOpcode.CONNECTION_CLOSE\n\n  frame.closeStatus = reasonCode;\n\n  if (typeof description === 'string') {\n    frame.binaryPayload = bufferFromString(description, 'utf8');\n  }\n\n  this.sendFrame(frame, cb);\n  this.socket.end();\n};\n\nWebSocketConnection.prototype.sendFrame = function (frame, cb) {\n  this._debug('sendFrame');\n\n  frame.mask = this.maskOutgoingPackets;\n  var flushed = this.socket.write(frame.toBuffer(), cb);\n  this.outputBufferFull = !flushed;\n  return flushed;\n};\n\nmodule.exports = WebSocketConnection;\n\nfunction instrumentSocketForDebugging(connection, socket) {\n  /* jshint loopfunc: true */\n  if (!connection._debug.enabled) {\n    return;\n  }\n\n  var originalSocketEmit = socket.emit;\n\n  socket.emit = function (event) {\n    connection._debug('||| Socket Event  \\'%s\\'', event);\n\n    originalSocketEmit.apply(this, arguments);\n  };\n\n  for (var key in socket) {\n    if ('function' !== typeof socket[key]) {\n      continue;\n    }\n\n    if (['emit'].indexOf(key) !== -1) {\n      continue;\n    }\n\n    (function (key) {\n      var original = socket[key];\n\n      if (key === 'on') {\n        socket[key] = function proxyMethod__EventEmitter__On() {\n          connection._debug('||| Socket method called:  %s (%s)', key, arguments[0]);\n\n          return original.apply(this, arguments);\n        };\n\n        return;\n      }\n\n      socket[key] = function proxyMethod() {\n        connection._debug('||| Socket method called:  %s', key);\n\n        return original.apply(this, arguments);\n      };\n    })(key);\n  }\n}","map":{"version":3,"sources":["/home/thaumy/Desktop/idb5-ui/node_modules/websocket/lib/WebSocketConnection.js"],"names":["util","require","utils","EventEmitter","WebSocketFrame","BufferList","isValidUTF8","bufferAllocUnsafe","bufferFromString","STATE_OPEN","STATE_PEER_REQUESTED_CLOSE","STATE_ENDING","STATE_CLOSED","setImmediateImpl","global","setImmediate","bind","process","nextTick","idCounter","WebSocketConnection","socket","extensions","protocol","maskOutgoingPackets","config","_debug","BufferingLogger","enabled","instrumentSocketForDebugging","call","_pingListenerCount","on","ev","remoteAddress","closeReasonCode","closeDescription","closeEventEmitted","maskBytes","frameHeader","bufferList","currentFrame","fragmentationSize","frameQueue","connected","state","waitingForCloseResponse","receivedEnd","closeTimeout","assembleFragments","maxReceivedMessageSize","outputBufferFull","inputPaused","receivedDataHandler","processReceivedData","_closeTimerHandler","handleCloseTimer","setNoDelay","disableNagleAlgorithm","setTimeout","keepalive","useNativeKeepalive","keepaliveInterval","Error","_keepaliveTimerHandler","handleKeepaliveTimer","setKeepaliveTimer","dropConnectionOnKeepaliveTimeout","keepaliveGracePeriod","_gracePeriodTimerHandler","handleGracePeriodTimer","setKeepAlive","removeAllListeners","CLOSE_REASON_NORMAL","CLOSE_REASON_GOING_AWAY","CLOSE_REASON_PROTOCOL_ERROR","CLOSE_REASON_UNPROCESSABLE_INPUT","CLOSE_REASON_RESERVED","CLOSE_REASON_NOT_PROVIDED","CLOSE_REASON_ABNORMAL","CLOSE_REASON_INVALID_DATA","CLOSE_REASON_POLICY_VIOLATION","CLOSE_REASON_MESSAGE_TOO_BIG","CLOSE_REASON_EXTENSION_REQUIRED","CLOSE_REASON_INTERNAL_SERVER_ERROR","CLOSE_REASON_TLS_HANDSHAKE_FAILED","CLOSE_DESCRIPTIONS","validateCloseReason","code","indexOf","inherits","prototype","_addSocketEventListeners","handleSocketError","handleSocketEnd","handleSocketClose","handleSocketDrain","handleSocketPause","handleSocketResume","handleSocketData","clearKeepaliveTimer","clearGracePeriodTimer","_keepaliveTimeoutID","clearTimeout","ping","setGracePeriodTimer","_gracePeriodTimeoutID","drop","data","write","frame","addData","self","protocolError","dropReason","frameTooLarge","rsv1","rsv2","rsv3","emit","processFrame","length","error","syscall","eventEmitterListenerCount","destroy","printOutput","end","hadError","socketHadError","clearCloseTimer","pause","resume","close","reasonCode","description","setCloseTimer","sendCloseFrame","skipCloseFrame","closeTimer","opcode","toString","fin","type","binaryData","binaryPayload","push","utf8Data","bytesCopied","forEach","copy","cancelled","cancel","pong","respondCloseReasonCode","invalidCloseFrameLength","closeStatus","send","cb","Buffer","isBuffer","sendBytes","sendUTF","fragmentAndSend","slice","sendFrame","threshold","fragmentationThreshold","fragmentOutgoingMessages","numFragments","Math","ceil","sentFragments","sentCallback","fragmentSentCallback","err","i","currentLength","sliceStart","mask","flushed","toBuffer","module","exports","connection","originalSocketEmit","event","apply","arguments","key","original","proxyMethod__EventEmitter__On","proxyMethod"],"mappings":"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","sourcesContent":["/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar util = require('util');\nvar utils = require('./utils');\nvar EventEmitter = require('events').EventEmitter;\nvar WebSocketFrame = require('./WebSocketFrame');\nvar BufferList = require('../vendor/FastBufferList');\nvar isValidUTF8 = require('utf-8-validate');\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\nvar bufferFromString = utils.bufferFromString;\n\n// Connected, fully-open, ready to send and receive frames\nconst STATE_OPEN = 'open';\n// Received a close frame from the remote peer\nconst STATE_PEER_REQUESTED_CLOSE = 'peer_requested_close';\n// Sent close frame to remote peer.  No further data can be sent.\nconst STATE_ENDING = 'ending';\n// Connection is fully closed.  No further data can be sent or received.\nconst STATE_CLOSED = 'closed';\n\nvar setImmediateImpl = ('setImmediate' in global) ?\n                            global.setImmediate.bind(global) :\n                            process.nextTick.bind(process);\n\nvar idCounter = 0;\n\nfunction WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {\n    this._debug = utils.BufferingLogger('websocket:connection', ++idCounter);\n    this._debug('constructor');\n    \n    if (this._debug.enabled) {\n        instrumentSocketForDebugging(this, socket);\n    }\n    \n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this._pingListenerCount = 0;\n    this.on('newListener', function(ev) {\n        if (ev === 'ping'){\n            this._pingListenerCount++;\n        }\n      }).on('removeListener', function(ev) {\n        if (ev === 'ping') {\n            this._pingListenerCount--;\n        }\n    });\n\n    this.config = config;\n    this.socket = socket;\n    this.protocol = protocol;\n    this.extensions = extensions;\n    this.remoteAddress = socket.remoteAddress;\n    this.closeReasonCode = -1;\n    this.closeDescription = null;\n    this.closeEventEmitted = false;\n\n    // We have to mask outgoing packets if we're acting as a WebSocket client.\n    this.maskOutgoingPackets = maskOutgoingPackets;\n\n    // We re-use the same buffers for the mask and frame header for all frames\n    // received on each connection to avoid a small memory allocation for each\n    // frame.\n    this.maskBytes = bufferAllocUnsafe(4);\n    this.frameHeader = bufferAllocUnsafe(10);\n\n    // the BufferList will handle the data streaming in\n    this.bufferList = new BufferList();\n\n    // Prepare for receiving first frame\n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    this.fragmentationSize = 0; // data received so far...\n    this.frameQueue = [];\n    \n    // Various bits of connection state\n    this.connected = true;\n    this.state = STATE_OPEN;\n    this.waitingForCloseResponse = false;\n    // Received TCP FIN, socket's readable stream is finished.\n    this.receivedEnd = false;\n\n    this.closeTimeout = this.config.closeTimeout;\n    this.assembleFragments = this.config.assembleFragments;\n    this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;\n\n    this.outputBufferFull = false;\n    this.inputPaused = false;\n    this.receivedDataHandler = this.processReceivedData.bind(this);\n    this._closeTimerHandler = this.handleCloseTimer.bind(this);\n\n    // Disable nagle algorithm?\n    this.socket.setNoDelay(this.config.disableNagleAlgorithm);\n\n    // Make sure there is no socket inactivity timeout\n    this.socket.setTimeout(0);\n\n    if (this.config.keepalive && !this.config.useNativeKeepalive) {\n        if (typeof(this.config.keepaliveInterval) !== 'number') {\n            throw new Error('keepaliveInterval must be specified and numeric ' +\n                            'if keepalive is true.');\n        }\n        this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);\n        this.setKeepaliveTimer();\n\n        if (this.config.dropConnectionOnKeepaliveTimeout) {\n            if (typeof(this.config.keepaliveGracePeriod) !== 'number') {\n                throw new Error('keepaliveGracePeriod  must be specified and ' +\n                                'numeric if dropConnectionOnKeepaliveTimeout ' +\n                                'is true.');\n            }\n            this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);\n        }\n    }\n    else if (this.config.keepalive && this.config.useNativeKeepalive) {\n        if (!('setKeepAlive' in this.socket)) {\n            throw new Error('Unable to use native keepalive: unsupported by ' +\n                            'this version of Node.');\n        }\n        this.socket.setKeepAlive(true, this.config.keepaliveInterval);\n    }\n    \n    // The HTTP Client seems to subscribe to socket error events\n    // and re-dispatch them in such a way that doesn't make sense\n    // for users of our client, so we want to make sure nobody\n    // else is listening for error events on the socket besides us.\n    this.socket.removeAllListeners('error');\n}\n\nWebSocketConnection.CLOSE_REASON_NORMAL = 1000;\nWebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;\nWebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;\nWebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;\nWebSocketConnection.CLOSE_REASON_RESERVED = 1004; // Reserved value.  Undefined meaning.\nWebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_ABNORMAL = 1006; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;\nWebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;\nWebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;\nWebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;\nWebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;\nWebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015; // Not to be used on the wire\n\nWebSocketConnection.CLOSE_DESCRIPTIONS = {\n    1000: 'Normal connection closure',\n    1001: 'Remote peer is going away',\n    1002: 'Protocol error',\n    1003: 'Unprocessable input',\n    1004: 'Reserved',\n    1005: 'Reason not provided',\n    1006: 'Abnormal closure, no further detail available',\n    1007: 'Invalid data received',\n    1008: 'Policy violation',\n    1009: 'Message too big',\n    1010: 'Extension requested by client is required',\n    1011: 'Internal Server Error',\n    1015: 'TLS Handshake Failed'\n};\n\nfunction validateCloseReason(code) {\n    if (code < 1000) {\n        // Status codes in the range 0-999 are not used\n        return false;\n    }\n    if (code >= 1000 && code <= 2999) {\n        // Codes from 1000 - 2999 are reserved for use by the protocol.  Only\n        // a few codes are defined, all others are currently illegal.\n        return [1000, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015].indexOf(code) !== -1;\n    }\n    if (code >= 3000 && code <= 3999) {\n        // Reserved for use by libraries, frameworks, and applications.\n        // Should be registered with IANA.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 4000 && code <= 4999) {\n        // Reserved for private use.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 5000) {\n        return false;\n    }\n}\n\nutil.inherits(WebSocketConnection, EventEmitter);\n\nWebSocketConnection.prototype._addSocketEventListeners = function() {\n    this.socket.on('error', this.handleSocketError.bind(this));\n    this.socket.on('end', this.handleSocketEnd.bind(this));\n    this.socket.on('close', this.handleSocketClose.bind(this));\n    this.socket.on('drain', this.handleSocketDrain.bind(this));\n    this.socket.on('pause', this.handleSocketPause.bind(this));\n    this.socket.on('resume', this.handleSocketResume.bind(this));\n    this.socket.on('data', this.handleSocketData.bind(this));\n};\n\n// set or reset the keepalive timer when data is received.\nWebSocketConnection.prototype.setKeepaliveTimer = function() {\n    this._debug('setKeepaliveTimer');\n    if (!this.config.keepalive  || this.config.useNativeKeepalive) { return; }\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);\n};\n\nWebSocketConnection.prototype.clearKeepaliveTimer = function() {\n    if (this._keepaliveTimeoutID) {\n        clearTimeout(this._keepaliveTimeoutID);\n    }\n};\n\n// No data has been received within config.keepaliveTimeout ms.\nWebSocketConnection.prototype.handleKeepaliveTimer = function() {\n    this._debug('handleKeepaliveTimer');\n    this._keepaliveTimeoutID = null;\n    this.ping();\n\n    // If we are configured to drop connections if the client doesn't respond\n    // then set the grace period timer.\n    if (this.config.dropConnectionOnKeepaliveTimeout) {\n        this.setGracePeriodTimer();\n    }\n    else {\n        // Otherwise reset the keepalive timer to send the next ping.\n        this.setKeepaliveTimer();\n    }\n};\n\nWebSocketConnection.prototype.setGracePeriodTimer = function() {\n    this._debug('setGracePeriodTimer');\n    this.clearGracePeriodTimer();\n    this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);\n};\n\nWebSocketConnection.prototype.clearGracePeriodTimer = function() {\n    if (this._gracePeriodTimeoutID) {\n        clearTimeout(this._gracePeriodTimeoutID);\n    }\n};\n\nWebSocketConnection.prototype.handleGracePeriodTimer = function() {\n    this._debug('handleGracePeriodTimer');\n    // If this is called, the client has not responded and is assumed dead.\n    this._gracePeriodTimeoutID = null;\n    this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, 'Peer not responding.', true);\n};\n\nWebSocketConnection.prototype.handleSocketData = function(data) {\n    this._debug('handleSocketData');\n    // Reset the keepalive timer when receiving data of any kind.\n    this.setKeepaliveTimer();\n\n    // Add received data to our bufferList, which efficiently holds received\n    // data chunks in a linked list of Buffer objects.\n    this.bufferList.write(data);\n\n    this.processReceivedData();\n};\n\nWebSocketConnection.prototype.processReceivedData = function() {\n    this._debug('processReceivedData');\n    // If we're not connected, we should ignore any data remaining on the buffer.\n    if (!this.connected) { return; }\n\n    // Receiving/parsing is expected to be halted when paused.\n    if (this.inputPaused) { return; }\n\n    var frame = this.currentFrame;\n\n    // WebSocketFrame.prototype.addData returns true if all data necessary to\n    // parse the frame was available.  It returns false if we are waiting for\n    // more data to come in on the wire.\n    if (!frame.addData(this.bufferList)) { this._debug('-- insufficient data for frame'); return; }\n\n    var self = this;\n\n    // Handle possible parsing errors\n    if (frame.protocolError) {\n        // Something bad happened.. get rid of this client.\n        this._debug('-- protocol error');\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);\n        });\n        return;\n    }\n    else if (frame.frameTooLarge) {\n        this._debug('-- frame too large');\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);\n        });\n        return;\n    }\n\n    // For now since we don't support extensions, all RSV bits are illegal\n    if (frame.rsv1 || frame.rsv2 || frame.rsv3) {\n        this._debug('-- illegal rsv flag');\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n              'Unsupported usage of rsv bits without negotiated extension.');\n        });\n        return;\n    }\n\n    if (!this.assembleFragments) {\n        this._debug('-- emitting frame');\n        process.nextTick(function() { self.emit('frame', frame); });\n    }\n\n    process.nextTick(function() { self.processFrame(frame); });\n    \n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n\n    // If there's data remaining, schedule additional processing, but yield\n    // for now so that other connections have a chance to have their data\n    // processed.  We use setImmediate here instead of process.nextTick to\n    // explicitly indicate that we wish for other I/O to be handled first.\n    if (this.bufferList.length > 0) {\n        setImmediateImpl(this.receivedDataHandler);\n    }\n};\n\nWebSocketConnection.prototype.handleSocketError = function(error) {\n    this._debug('handleSocketError: %j', error);\n    if (this.state === STATE_CLOSED) {\n\t\t// See https://github.com/theturtle32/WebSocket-Node/issues/288\n        this._debug('  --- Socket \\'error\\' after \\'close\\'');\n        return;\n    }\n    this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n    this.closeDescription = 'Socket Error: ' + error.syscall + ' ' + error.code;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.fragmentationSize = 0;\n    if (utils.eventEmitterListenerCount(this, 'error') > 0) {\n        this.emit('error', error);\n    }\n    this.socket.destroy();\n    this._debug.printOutput();\n};\n\nWebSocketConnection.prototype.handleSocketEnd = function() {\n    this._debug('handleSocketEnd: received socket end.  state = %s', this.state);\n    this.receivedEnd = true;\n    if (this.state === STATE_CLOSED) {\n        // When using the TLS module, sometimes the socket will emit 'end'\n        // after it emits 'close'.  I don't think that's correct behavior,\n        // but we should deal with it gracefully by ignoring it.\n        this._debug('  --- Socket \\'end\\' after \\'close\\'');\n        return;\n    }\n    if (this.state !== STATE_PEER_REQUESTED_CLOSE &&\n        this.state !== STATE_ENDING) {\n      this._debug('  --- UNEXPECTED socket end.');\n      this.socket.end();\n    }\n};\n\nWebSocketConnection.prototype.handleSocketClose = function(hadError) {\n    this._debug('handleSocketClose: received socket close');\n    this.socketHadError = hadError;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    // If closeReasonCode is still set to -1 at this point then we must\n    // not have received a close frame!!\n    if (this.closeReasonCode === -1) {\n        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n        this.closeDescription = 'Connection dropped by remote peer.';\n    }\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug('-- Emitting WebSocketConnection close event');\n        this.emit('close', this.closeReasonCode, this.closeDescription);\n    }\n};\n\nWebSocketConnection.prototype.handleSocketDrain = function() {\n    this._debug('handleSocketDrain: socket drain event');\n    this.outputBufferFull = false;\n    this.emit('drain');\n};\n\nWebSocketConnection.prototype.handleSocketPause = function() {\n    this._debug('handleSocketPause: socket pause event');\n    this.inputPaused = true;\n    this.emit('pause');\n};\n\nWebSocketConnection.prototype.handleSocketResume = function() {\n    this._debug('handleSocketResume: socket resume event');\n    this.inputPaused = false;\n    this.emit('resume');\n    this.processReceivedData();\n};\n\nWebSocketConnection.prototype.pause = function() {\n    this._debug('pause: pause requested');\n    this.socket.pause();\n};\n\nWebSocketConnection.prototype.resume = function() {\n    this._debug('resume: resume requested');\n    this.socket.resume();\n};\n\nWebSocketConnection.prototype.close = function(reasonCode, description) {\n    if (this.connected) {\n        this._debug('close: Initating clean WebSocket close sequence.');\n        if ('number' !== typeof reasonCode) {\n            reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n        }\n        if (!validateCloseReason(reasonCode)) {\n            throw new Error('Close code ' + reasonCode + ' is not valid.');\n        }\n        if ('string' !== typeof description) {\n            description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n        }\n        this.closeReasonCode = reasonCode;\n        this.closeDescription = description;\n        this.setCloseTimer();\n        this.sendCloseFrame(this.closeReasonCode, this.closeDescription);\n        this.state = STATE_ENDING;\n        this.connected = false;\n    }\n};\n\nWebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {\n    this._debug('drop');\n    if (typeof(reasonCode) !== 'number') {\n        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n    }\n\n    if (typeof(description) !== 'string') {\n        // If no description is provided, try to look one up based on the\n        // specified reasonCode.\n        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n    }\n\n    this._debug('Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s',\n        skipCloseFrame, reasonCode, description\n    );\n\n    this.closeReasonCode = reasonCode;\n    this.closeDescription = description;\n    this.frameQueue = [];\n    this.fragmentationSize = 0;\n    if (!skipCloseFrame) {\n        this.sendCloseFrame(reasonCode, description);\n    }\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug('Emitting WebSocketConnection close event');\n        this.emit('close', this.closeReasonCode, this.closeDescription);\n    }\n    \n    this._debug('Drop: destroying socket');\n    this.socket.destroy();\n};\n\nWebSocketConnection.prototype.setCloseTimer = function() {\n    this._debug('setCloseTimer');\n    this.clearCloseTimer();\n    this._debug('Setting close timer');\n    this.waitingForCloseResponse = true;\n    this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);\n};\n\nWebSocketConnection.prototype.clearCloseTimer = function() {\n    this._debug('clearCloseTimer');\n    if (this.closeTimer) {\n        this._debug('Clearing close timer');\n        clearTimeout(this.closeTimer);\n        this.waitingForCloseResponse = false;\n        this.closeTimer = null;\n    }\n};\n\nWebSocketConnection.prototype.handleCloseTimer = function() {\n    this._debug('handleCloseTimer');\n    this.closeTimer = null;\n    if (this.waitingForCloseResponse) {\n        this._debug('Close response not received from client.  Forcing socket end.');\n        this.waitingForCloseResponse = false;\n        this.state = STATE_CLOSED;\n        this.socket.end();\n    }\n};\n\nWebSocketConnection.prototype.processFrame = function(frame) {\n    this._debug('processFrame');\n    this._debug(' -- frame: %s', frame);\n    \n    // Any non-control opcode besides 0x00 (continuation) received in the\n    // middle of a fragmented message is illegal.\n    if (this.frameQueue.length !== 0 && (frame.opcode > 0x00 && frame.opcode < 0x08)) {\n        this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n          'Illegal frame opcode 0x' + frame.opcode.toString(16) + ' ' +\n          'received in middle of fragmented message.');\n        return;\n    }\n\n    switch(frame.opcode) {\n        case 0x02: // WebSocketFrame.BINARY_FRAME\n            this._debug('-- Binary Frame');\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    // Complete single-frame message received\n                    this._debug('---- Emitting \\'message\\' event');\n                    this.emit('message', {\n                        type: 'binary',\n                        binaryData: frame.binaryPayload\n                    });\n                }\n                else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x01: // WebSocketFrame.TEXT_FRAME\n            this._debug('-- Text Frame');\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    if (!isValidUTF8(frame.binaryPayload)) {\n                        this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,\n                          'Invalid UTF-8 Data Received');\n                        return;\n                    }\n                    // Complete single-frame message received\n                    this._debug('---- Emitting \\'message\\' event');\n                    this.emit('message', {\n                        type: 'utf8',\n                        utf8Data: frame.binaryPayload.toString('utf8')\n                    });\n                }\n                else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x00: // WebSocketFrame.CONTINUATION\n            this._debug('-- Continuation Frame');\n            if (this.assembleFragments) {\n                if (this.frameQueue.length === 0) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n                      'Unexpected Continuation Frame');\n                    return;\n                }\n\n                this.fragmentationSize += frame.length;\n\n                if (this.fragmentationSize > this.maxReceivedMessageSize) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG,\n                      'Maximum message size exceeded.');\n                    return;\n                }\n\n                this.frameQueue.push(frame);\n\n                if (frame.fin) {\n                    // end of fragmented message, so we process the whole\n                    // message now.  We also have to decode the utf-8 data\n                    // for text frames after combining all the fragments.\n                    var bytesCopied = 0;\n                    var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);\n                    var opcode = this.frameQueue[0].opcode;\n                    this.frameQueue.forEach(function (currentFrame) {\n                        currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);\n                        bytesCopied += currentFrame.binaryPayload.length;\n                    });\n                    this.frameQueue = [];\n                    this.fragmentationSize = 0;\n\n                    switch (opcode) {\n                        case 0x02: // WebSocketOpcode.BINARY_FRAME\n                            this.emit('message', {\n                                type: 'binary',\n                                binaryData: binaryPayload\n                            });\n                            break;\n                        case 0x01: // WebSocketOpcode.TEXT_FRAME\n                            if (!isValidUTF8(binaryPayload)) {\n                                this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,\n                                  'Invalid UTF-8 Data Received');\n                                return;\n                            }\n                            this.emit('message', {\n                                type: 'utf8',\n                                utf8Data: binaryPayload.toString('utf8')\n                            });\n                            break;\n                        default:\n                            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n                              'Unexpected first opcode in fragmentation sequence: 0x' + opcode.toString(16));\n                            return;\n                    }\n                }\n            }\n            break;\n        case 0x09: // WebSocketFrame.PING\n            this._debug('-- Ping Frame');\n\n            if (this._pingListenerCount > 0) {\n                // logic to emit the ping frame: this is only done when a listener is known to exist\n                // Expose a function allowing the user to override the default ping() behavior\n                var cancelled = false;\n                var cancel = function() { \n                  cancelled = true; \n                };\n                this.emit('ping', cancel, frame.binaryPayload);\n\n                // Only send a pong if the client did not indicate that he would like to cancel\n                if (!cancelled) {\n                    this.pong(frame.binaryPayload);\n                }\n            }\n            else {\n                this.pong(frame.binaryPayload);\n            }\n\n            break;\n        case 0x0A: // WebSocketFrame.PONG\n            this._debug('-- Pong Frame');\n            this.emit('pong', frame.binaryPayload);\n            break;\n        case 0x08: // WebSocketFrame.CONNECTION_CLOSE\n            this._debug('-- Close Frame');\n            if (this.waitingForCloseResponse) {\n                // Got response to our request to close the connection.\n                // Close is complete, so we just hang up.\n                this._debug('---- Got close response from peer.  Completing closing handshake.');\n                this.clearCloseTimer();\n                this.waitingForCloseResponse = false;\n                this.state = STATE_CLOSED;\n                this.socket.end();\n                return;\n            }\n            \n            this._debug('---- Closing handshake initiated by peer.');\n            // Got request from other party to close connection.\n            // Send back acknowledgement and then hang up.\n            this.state = STATE_PEER_REQUESTED_CLOSE;\n            var respondCloseReasonCode;\n\n            // Make sure the close reason provided is legal according to\n            // the protocol spec.  Providing no close status is legal.\n            // WebSocketFrame sets closeStatus to -1 by default, so if it\n            // is still -1, then no status was provided.\n            if (frame.invalidCloseFrameLength) {\n                this.closeReasonCode = 1005; // 1005 = No reason provided.\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            }\n            else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n            }\n            else {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            }\n            \n            // If there is a textual description in the close frame, extract it.\n            if (frame.binaryPayload.length > 1) {\n                if (!isValidUTF8(frame.binaryPayload)) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,\n                      'Invalid UTF-8 Data Received');\n                    return;\n                }\n                this.closeDescription = frame.binaryPayload.toString('utf8');\n            }\n            else {\n                this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];\n            }\n            this._debug(\n                '------ Remote peer %s - code: %d - %s - close frame payload length: %d',\n                this.remoteAddress, this.closeReasonCode,\n                this.closeDescription, frame.length\n            );\n            this._debug('------ responding to remote peer\\'s close request.');\n            this.sendCloseFrame(respondCloseReasonCode, null);\n            this.connected = false;\n            break;\n        default:\n            this._debug('-- Unrecognized Opcode %d', frame.opcode);\n            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n              'Unrecognized Opcode: 0x' + frame.opcode.toString(16));\n            break;\n    }\n};\n\nWebSocketConnection.prototype.send = function(data, cb) {\n    this._debug('send');\n    if (Buffer.isBuffer(data)) {\n        this.sendBytes(data, cb);\n    }\n    else if (typeof(data['toString']) === 'function') {\n        this.sendUTF(data, cb);\n    }\n    else {\n        throw new Error('Data provided must either be a Node Buffer or implement toString()');\n    }\n};\n\nWebSocketConnection.prototype.sendUTF = function(data, cb) {\n    data = bufferFromString(data.toString(), 'utf8');\n    this._debug('sendUTF: %d bytes', data.length);\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x01; // WebSocketOpcode.TEXT_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\n\nWebSocketConnection.prototype.sendBytes = function(data, cb) {\n    this._debug('sendBytes');\n    if (!Buffer.isBuffer(data)) {\n        throw new Error('You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()');\n    }\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x02; // WebSocketOpcode.BINARY_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\n\nWebSocketConnection.prototype.ping = function(data) {\n    this._debug('ping');\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x09; // WebSocketOpcode.PING\n    frame.fin = true;\n    if (data) {\n        if (!Buffer.isBuffer(data)) {\n            data = bufferFromString(data.toString(), 'utf8');\n        }\n        if (data.length > 125) {\n            this._debug('WebSocket: Data for ping is longer than 125 bytes.  Truncating.');\n            data = data.slice(0,124);\n        }\n        frame.binaryPayload = data;\n    }\n    this.sendFrame(frame);\n};\n\n// Pong frames have to echo back the contents of the data portion of the\n// ping frame exactly, byte for byte.\nWebSocketConnection.prototype.pong = function(binaryPayload) {\n    this._debug('pong');\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x0A; // WebSocketOpcode.PONG\n    if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {\n        this._debug('WebSocket: Data for pong is longer than 125 bytes.  Truncating.');\n        binaryPayload = binaryPayload.slice(0,124);\n    }\n    frame.binaryPayload = binaryPayload;\n    frame.fin = true;\n    this.sendFrame(frame);\n};\n\nWebSocketConnection.prototype.fragmentAndSend = function(frame, cb) {\n    this._debug('fragmentAndSend');\n    if (frame.opcode > 0x07) {\n        throw new Error('You cannot fragment control frames.');\n    }\n\n    var threshold = this.config.fragmentationThreshold;\n    var length = frame.binaryPayload.length;\n\n    // Send immediately if fragmentation is disabled or the message is not\n    // larger than the fragmentation threshold.\n    if (!this.config.fragmentOutgoingMessages || (frame.binaryPayload && length <= threshold)) {\n        frame.fin = true;\n        this.sendFrame(frame, cb);\n        return;\n    }\n    \n    var numFragments = Math.ceil(length / threshold);\n    var sentFragments = 0;\n    var sentCallback = function fragmentSentCallback(err) {\n        if (err) {\n            if (typeof cb === 'function') {\n                // pass only the first error\n                cb(err);\n                cb = null;\n            }\n            return;\n        }\n        ++sentFragments;\n        if ((sentFragments === numFragments) && (typeof cb === 'function')) {\n            cb();\n        }\n    };\n    for (var i=1; i <= numFragments; i++) {\n        var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n        \n        // continuation opcode except for first frame.\n        currentFrame.opcode = (i === 1) ? frame.opcode : 0x00;\n        \n        // fin set on last frame only\n        currentFrame.fin = (i === numFragments);\n        \n        // length is likely to be shorter on the last fragment\n        var currentLength = (i === numFragments) ? length - (threshold * (i-1)) : threshold;\n        var sliceStart = threshold * (i-1);\n        \n        // Slice the right portion of the original payload\n        currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);\n        \n        this.sendFrame(currentFrame, sentCallback);\n    }\n};\n\nWebSocketConnection.prototype.sendCloseFrame = function(reasonCode, description, cb) {\n    if (typeof(reasonCode) !== 'number') {\n        reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n    }\n    \n    this._debug('sendCloseFrame state: %s, reasonCode: %d, description: %s', this.state, reasonCode, description);\n    \n    if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) { return; }\n    \n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.fin = true;\n    frame.opcode = 0x08; // WebSocketOpcode.CONNECTION_CLOSE\n    frame.closeStatus = reasonCode;\n    if (typeof(description) === 'string') {\n        frame.binaryPayload = bufferFromString(description, 'utf8');\n    }\n    \n    this.sendFrame(frame, cb);\n    this.socket.end();\n};\n\nWebSocketConnection.prototype.sendFrame = function(frame, cb) {\n    this._debug('sendFrame');\n    frame.mask = this.maskOutgoingPackets;\n    var flushed = this.socket.write(frame.toBuffer(), cb);\n    this.outputBufferFull = !flushed;\n    return flushed;\n};\n\nmodule.exports = WebSocketConnection;\n\n\n\nfunction instrumentSocketForDebugging(connection, socket) {\n    /* jshint loopfunc: true */\n    if (!connection._debug.enabled) { return; }\n    \n    var originalSocketEmit = socket.emit;\n    socket.emit = function(event) {\n        connection._debug('||| Socket Event  \\'%s\\'', event);\n        originalSocketEmit.apply(this, arguments);\n    };\n    \n    for (var key in socket) {\n        if ('function' !== typeof(socket[key])) { continue; }\n        if (['emit'].indexOf(key) !== -1) { continue; }\n        (function(key) {\n            var original = socket[key];\n            if (key === 'on') {\n                socket[key] = function proxyMethod__EventEmitter__On() {\n                    connection._debug('||| Socket method called:  %s (%s)', key, arguments[0]);\n                    return original.apply(this, arguments);\n                };\n                return;\n            }\n            socket[key] = function proxyMethod() {\n                connection._debug('||| Socket method called:  %s', key);\n                return original.apply(this, arguments);\n            };\n        })(key);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}