{"ast":null,"code":"// Utilities\nimport { onBeforeUnmount, ref, watch } from 'vue';\nexport function useIntersectionObserver(callback) {\n  const intersectionRef = ref();\n  const isIntersecting = ref(false);\n  const observer = new IntersectionObserver(entries => {\n    callback == null ? void 0 : callback(entries, observer);\n    isIntersecting.value = !!entries.find(entry => entry.isIntersecting);\n  });\n  onBeforeUnmount(() => {\n    observer.disconnect();\n  });\n  watch(intersectionRef, (newValue, oldValue) => {\n    if (oldValue) {\n      observer.unobserve(oldValue);\n      isIntersecting.value = false;\n    }\n\n    if (newValue) observer.observe(newValue);\n  }, {\n    flush: 'post'\n  });\n  return {\n    intersectionRef,\n    isIntersecting\n  };\n}","map":{"version":3,"mappings":"AAAA;AACA,SAASA,eAAT,EAA0BC,GAA1B,EAA+BC,KAA/B,QAA4C,KAA5C;AAEA,OAAO,SAASC,uBAAT,CAAkCC,QAAlC,EAA2E;AAChF,QAAMC,eAAe,GAAGJ,GAAG,EAA3B;AACA,QAAMK,cAAc,GAAGL,GAAG,CAAC,KAAD,CAA1B;AAEA,QAAMM,QAAQ,GAAG,IAAIC,oBAAJ,CAA0BC,OAAD,IAA0C;AAClFL,YAAQ,QAARA,oBAAQ,CAAGK,OAAH,EAAYF,QAAZ,CAARH;AAEAE,kBAAc,CAACI,KAAfJ,GAAuB,CAAC,CAACG,OAAO,CAACE,IAARF,CAAaG,KAAK,IAAIA,KAAK,CAACN,cAA5BG,CAAzBH;AAHe,IAAjB;AAMAN,iBAAe,CAAC,MAAM;AACpBO,YAAQ,CAACM,UAATN;AADa,IAAfP;AAIAE,OAAK,CAACG,eAAD,EAAkB,CAACS,QAAD,EAAWC,QAAX,KAAwB;AAC7C,QAAIA,QAAJ,EAAc;AACZR,cAAQ,CAACS,SAATT,CAAmBQ,QAAnBR;AACAD,oBAAc,CAACI,KAAfJ,GAAuB,KAAvBA;AACD;;AAED,QAAIQ,QAAJ,EAAcP,QAAQ,CAACU,OAATV,CAAiBO,QAAjBP;AANX,KAOF;AACDW,SAAK,EAAE;AADN,GAPE,CAALhB;AAWA,SAAO;AAAEG,mBAAF;AAAmBC;AAAnB,GAAP;AACD","names":["onBeforeUnmount","ref","watch","useIntersectionObserver","callback","intersectionRef","isIntersecting","observer","IntersectionObserver","entries","value","find","entry","disconnect","newValue","oldValue","unobserve","observe","flush"],"sources":["../../src/composables/intersectionObserver.ts"],"sourcesContent":["// Utilities\nimport { onBeforeUnmount, ref, watch } from 'vue'\n\nexport function useIntersectionObserver (callback?: IntersectionObserverCallback) {\n  const intersectionRef = ref<HTMLElement>()\n  const isIntersecting = ref(false)\n\n  const observer = new IntersectionObserver((entries: IntersectionObserverEntry[]) => {\n    callback?.(entries, observer)\n\n    isIntersecting.value = !!entries.find(entry => entry.isIntersecting)\n  })\n\n  onBeforeUnmount(() => {\n    observer.disconnect()\n  })\n\n  watch(intersectionRef, (newValue, oldValue) => {\n    if (oldValue) {\n      observer.unobserve(oldValue)\n      isIntersecting.value = false\n    }\n\n    if (newValue) observer.observe(newValue)\n  }, {\n    flush: 'post',\n  })\n\n  return { intersectionRef, isIntersecting }\n}\n"]},"metadata":{},"sourceType":"module"}