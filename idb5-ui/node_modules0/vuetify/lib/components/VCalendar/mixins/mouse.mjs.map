{"version":3,"sources":["../../../../src/components/VCalendar/mixins/mouse.ts"],"names":["Vue","extend","name","methods","getDefaultMouseEventHandlers","suffix","getEvent","getMouseEventHandlers","event","prevent","result","events","on","eventOptions","$listeners","prefix","passive","once","capture","key","handler","e","mouseEvent","button","undefined","buttons","preventDefault","stop","stopPropagation","currentTarget","document","elementFromPoint","changedTouches","clientX","clientY","target","isSameNode","className","dispatchEvent","TouchEvent","type","targetTouches","touches","$emit","Array","isArray","push"],"mappings":"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","sourcesContent":["// @ts-nocheck\n/* eslint-disable */\n\nimport Vue from 'vue'\n\nexport type MouseHandler = (e: MouseEvent | TouchEvent) => any\n\nexport type MouseEvents = {\n  [event: string]: {\n    event: string\n    passive?: boolean\n    capture?: boolean\n    once?: boolean\n    stop?: boolean\n    prevent?: boolean\n    button?: number\n    result?: any\n  }\n}\n\nexport type MouseEventsMap = {\n  [event: string]: MouseHandler | MouseHandler[]\n}\n\nexport default Vue.extend({\n  name: 'mouse',\n\n  methods: {\n    getDefaultMouseEventHandlers (suffix: string, getEvent: MouseHandler): MouseEventsMap {\n      return this.getMouseEventHandlers({\n        ['click' + suffix]: { event: 'click' },\n        ['contextmenu' + suffix]: { event: 'contextmenu', prevent: true, result: false },\n        ['mousedown' + suffix]: { event: 'mousedown' },\n        ['mousemove' + suffix]: { event: 'mousemove' },\n        ['mouseup' + suffix]: { event: 'mouseup' },\n        ['mouseenter' + suffix]: { event: 'mouseenter' },\n        ['mouseleave' + suffix]: { event: 'mouseleave' },\n        ['touchstart' + suffix]: { event: 'touchstart' },\n        ['touchmove' + suffix]: { event: 'touchmove' },\n        ['touchend' + suffix]: { event: 'touchend' },\n      }, getEvent)\n    },\n    getMouseEventHandlers (events: MouseEvents, getEvent: MouseHandler): MouseEventsMap {\n      const on: MouseEventsMap = {}\n\n      for (const event in events) {\n        const eventOptions = events[event]\n\n        if (!this.$listeners[event]) continue\n\n        // TODO somehow pull in modifiers\n\n        const prefix = eventOptions.passive ? '&' : ((eventOptions.once ? '~' : '') + (eventOptions.capture ? '!' : ''))\n        const key = prefix + eventOptions.event\n\n        const handler: MouseHandler = e => {\n          const mouseEvent: MouseEvent = e as MouseEvent\n          if (eventOptions.button === undefined || (mouseEvent.buttons > 0 && mouseEvent.button === eventOptions.button)) {\n            if (eventOptions.prevent) {\n              e.preventDefault()\n            }\n            if (eventOptions.stop) {\n              e.stopPropagation()\n            }\n\n            // Due to TouchEvent target always returns the element that is first placed\n            // Even if touch point has since moved outside the interactive area of that element\n            // Ref: https://developer.mozilla.org/en-US/docs/Web/API/Touch/target\n            // This block of code aims to make sure touchEvent is always dispatched from the element that is being pointed at\n            if (e && 'touches' in e) {\n              const currentTarget = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY)\n\n              if (currentTarget &&\n                !(e.target as HTMLElement)?.isSameNode(currentTarget) &&\n                (e.target as HTMLElement)?.className === currentTarget.className\n              ) {\n                currentTarget.dispatchEvent(new TouchEvent(e.type, {\n                  changedTouches: e.changedTouches as unknown as Touch[],\n                  targetTouches: e.targetTouches as unknown as Touch[],\n                  touches: e.touches as unknown as Touch[],\n                }))\n                return\n              }\n            }\n\n            this.$emit(event, getEvent(e), e)\n          }\n\n          return eventOptions.result\n        }\n\n        if (key in on) {\n          /* istanbul ignore next */\n          if (Array.isArray(on[key])) {\n            (on[key] as MouseHandler[]).push(handler)\n          } else {\n            on[key] = [on[key], handler] as MouseHandler[]\n          }\n        } else {\n          on[key] = handler\n        }\n      }\n\n      return on\n    },\n  },\n})\n"],"file":"mouse.mjs"}