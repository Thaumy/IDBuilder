{"version":3,"sources":["../../../../src/components/VOverlay/util/anchor.ts"],"names":["block","inline","parseAnchor","anchor","side","align","split","oppositeAnchor","center","top","bottom","start","end","physicalAnchor","el","direction","window","getComputedStyle","map"],"mappings":"AAAA,MAAMA,KAAK,GAAG,CAAC,KAAD,EAAQ,QAAR,CAAd;AACA,MAAMC,MAAM,GAAG,CAAC,OAAD,EAAU,KAAV,CAAf;;AAeA;AACA,OAAO,SAASC,WAAT,CAAsBC,MAAtB,EAAsC;AAC3C,MAAI,CAACC,IAAD,EAAOC,KAAP,IAAgBF,MAAM,CAACG,KAAP,CAAa,GAAb,CAApB;;AACA,MAAI,CAACD,KAAL,EAAY;AACVA,IAAAA,KAAK,GACHD,IAAI,KAAK,KAAT,IAAkBA,IAAI,KAAK,QAA3B,GAAsC,OAAtC,GACEA,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,KAA7B,GAAqC,KAArC,GACA,QAHJ;AAID;;AACD,SAAO;AACLA,IAAAA,IADK;AAELC,IAAAA;AAFK,GAAP;AAID;AAED;;AACA,OAAO,SAASE,cAAT,CAAyBJ,MAAzB,EAA+C;AACpD,SAAO;AACLC,IAAAA,IAAI,EAAE;AACJI,MAAAA,MAAM,EAAE,QADJ;AAEJC,MAAAA,GAAG,EAAE,QAFD;AAGJC,MAAAA,MAAM,EAAE,KAHJ;AAIJC,MAAAA,KAAK,EAAE,KAJH;AAKJC,MAAAA,GAAG,EAAE;AALD,MAMJT,MAAM,CAACC,IANH,CADD;AAQLC,IAAAA,KAAK,EAAEF,MAAM,CAACE;AART,GAAP;AAUD;AAED;;AACA,OAAO,SAASQ,cAAT,CAAyBV,MAAzB,EAA+CW,EAA/C,EAAgE;AAAA;;AACrE,QAAM;AAAEV,IAAAA,IAAF;AAAQC,IAAAA;AAAR,MAAkBF,MAAxB;AACA,QAAM;AAAEY,IAAAA;AAAF,MAAgBC,MAAM,CAACC,gBAAP,CAAwBH,EAAxB,CAAtB;AAEA,QAAMI,GAAmC,GAAGH,SAAS,KAAK,KAAd,GAAsB;AAChEJ,IAAAA,KAAK,EAAE,MADyD;AAEhEC,IAAAA,GAAG,EAAE;AAF2D,GAAtB,GAGxC;AACFD,IAAAA,KAAK,EAAE,OADL;AAEFC,IAAAA,GAAG,EAAE;AAFH,GAHJ;AAQA,SAAO,cAACM,GAAG,CAACd,IAAD,CAAJ,wBAAcA,IAAd,IAAsB,GAAtB,kBAA6Bc,GAAG,CAACb,KAAD,CAAhC,yBAA2CA,KAA3C,CAAP;AACD","sourcesContent":["const block = ['top', 'bottom'] as const\nconst inline = ['start', 'end'] as const\ntype Tblock = typeof block[number]\ntype Tinline = typeof inline [number]\nexport type Anchor =\n  | Tblock\n  | Tinline\n  | 'center'\n  | 'center center'\n  | `${Tblock} ${Tinline | 'center'}`\n  | `${Tinline} ${Tblock | 'center'}`\nexport type ParsedAnchor =\n  | { side: 'center', align: 'center' }\n  | { side: Tblock, align: Tinline | 'center' }\n  | { side: Tinline, align: Tblock | 'center' }\n\n/** Parse a raw anchor string into an object */\nexport function parseAnchor (anchor: Anchor) {\n  let [side, align] = anchor.split(' ')\n  if (!align) {\n    align =\n      side === 'top' || side === 'bottom' ? 'start'\n      : side === 'start' || side === 'end' ? 'top'\n      : 'center'\n  }\n  return {\n    side,\n    align,\n  } as ParsedAnchor\n}\n\n/** Get an anchor directly opposite, with the same alignment */\nexport function oppositeAnchor (anchor: ParsedAnchor) {\n  return {\n    side: {\n      center: 'center',\n      top: 'bottom',\n      bottom: 'top',\n      start: 'end',\n      end: 'start',\n    }[anchor.side],\n    align: anchor.align,\n  } as ParsedAnchor\n}\n\n/** Convert start/end into left/right */\nexport function physicalAnchor (anchor: ParsedAnchor, el: HTMLElement) {\n  const { side, align } = anchor\n  const { direction } = window.getComputedStyle(el)\n\n  const map: Dictionary<string | undefined> = direction === 'ltr' ? {\n    start: 'left',\n    end: 'right',\n  } : {\n    start: 'right',\n    end: 'left',\n  }\n\n  return (map[side] ?? side) + ' ' + (map[align] ?? align)\n}\n"],"file":"anchor.mjs"}